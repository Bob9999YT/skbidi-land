<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connect Four</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background-color: #1e1e2f;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 600px;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2rem;
      color: #ffaa00;
      margin: 0;
      text-align: center;
    }
    .user-profile {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #29293d;
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid #ffaa00;
      user-select: none;
    }
    .user-profile .avatar-circle {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #ffaa00;
      color: #111;
      font-weight: 700;
      font-size: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-transform: uppercase;
      overflow: hidden;
    }
    .user-profile .avatar-circle img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    .user-profile span {
      font-weight: 600;
      color: #ffaa00;
    }
    /* Matches container styles */
    #matchesContainer {
      max-width: 600px;
      width: 100%;
      max-height: 240px;
      overflow-y: auto;
      padding: 8px;
      background: #1f1f2b;
      border: 1.5px solid #ffaa00;
      border-radius: 6px;
      margin-top: 10px;
    }
    .matchItem {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #29293d;
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 6px;
    }
    .matchItem .playerInfo {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    button {
      background: #ffaa00;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      color: #111;
      font-weight: 600;
      cursor: pointer;
    }
    button:disabled {
      background: #444;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="usernamePromptContainer">
    <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
    <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" />
    <input id="avatarUrlInput" type="text" placeholder="Avatar Image/GIF URL (optional)"
           style="margin:10px 0; padding:8px; width:100%; background:#1f1f2b; color:white; border:2px solid #ffaa00; border-radius:6px;" />
    <button id="usernameSubmit" disabled>Start Playing</button>
  </div>

  <div class="header" style="display:none;">
    <h1>Connect Four</h1>
    <div class="user-profile">
      <div class="avatar-circle" id="userAvatar"></div>
      <span id="username">Guest</span>
    </div>
  </div>

  <div style="max-width: 600px; width: 100%; margin-top: 10px;">
    <label>Rows:
      <select id="rows"></select>
    </label>
    <label>Columns:
      <select id="cols"></select>
    </label>
    <label>Mode:
      <select id="mode">
        <option value="pvp">Player vs Player</option>
        <option value="ai">Player vs AI</option>
      </select>
    </label>
    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420" style="margin-top: 20px; display:none; border-radius: 8px;"></canvas>
  <div id="status" style="margin-top: 20px; text-align: center;"></div>

  <div id="matchList" style="max-width: 600px; width: 100%; margin-top: 20px; display:none;">
    <h3 style="color:#ffaa00; text-align:center;">Available Matches</h3>
    <button id="refreshMatchesBtn" style="width: 100%; margin-bottom: 10px;">ðŸ”„ Refresh Matches</button>
    <div id="matchesContainer">
      <div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>
    </div>
  </div>

<script>
(() => {
  // Constants for player IDs
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;

  // Game state variables
  let currentUser = { username: null, avatarUrl: null };
  let currentUserId = null;
  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let isInMatch = false;

  // DOM elements
  const usernameInput = document.getElementById('usernameInput');
  const avatarUrlInput = document.getElementById('avatarUrlInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const usernameSpan = document.getElementById('username');
  const userAvatarDiv = document.getElementById('userAvatar');
  const header = document.querySelector('.header');
  const promptContainer = document.getElementById('usernamePromptContainer');
  const statusText = document.getElementById('status');
  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const matchListDiv = document.getElementById('matchList');
  const matchesContainer = document.getElementById('matchesContainer');
  const refreshBtn = document.getElementById('refreshMatchesBtn');

  const STORAGE_KEY = 'connect_four_global_matches';
  const matches = {};

  // Utility: Generate a consistent color from a string
  function getAvatarColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const colors = ['#f44336','#e91e63','#9c27b0','#673ab7','#3f51b5','#2196f3','#03a9f4','#00bcd4','#009688','#4caf50','#8bc34a','#cddc39','#ffeb3b','#ffc107','#ff9800','#ff5722'];
    return colors[Math.abs(hash) % colors.length];
  }

  // Initialize board matrix
  function initBoard() {
    board = Array.from({ length: rows }, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  // Update canvas size based on rows and columns
  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    drawBoard();
  }

  // Draw the game board on the canvas
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw background grid
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let x = c * 70;
        let y = r * 70;

        // Empty circle background
        ctx.fillStyle = '#1e1e2f';
        ctx.beginPath();
        ctx.arc(x + 35, y + 35, 30, 0, 2 * Math.PI);
        ctx.fill();

        // Draw piece if placed
        if (board[r][c] === PLAYER_RED) {
          ctx.fillStyle = '#ff3333';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        } else if (board[r][c] === PLAYER_YELLOW) {
          ctx.fillStyle = '#ffff66';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
  }

  // Find the lowest empty row in a column
  function findLowestEmptyRow(col) {
    for (let r = rows - 1; r >= 0; r--) {
      if (board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  // Check if a player has won
  function checkWin(player) {
    // horizontal
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0, 1, 2, 3].every(i => board[r][c + i] === player)) return true;
      }
    }
    // vertical
    for (let c = 0; c < cols; c++) {
      for (let r = 0; r <= rows - 4; r++) {
        if ([0, 1, 2, 3].every(i => board[r + i][c] === player)) return true;
      }
    }
    // diagonal /
    for (let r = 3; r < rows; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0, 1, 2, 3].every(i => board[r - i][c + i] === player)) return true;
      }
    }
    // diagonal \
    for (let r = 0; r <= rows - 4; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0, 1, 2, 3].every(i => board[r + i][c + i] === player)) return true;
      }
    }
    return false;
  }

  // Check if board is full -> draw
  function checkDraw() {
    return board[0].every(cell => cell !== PLAYER_NONE);
  }

  // Save matches to localStorage
  function saveGlobalMatches() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
    window.dispatchEvent(new Event('storage'));
  }

  // Load matches from localStorage
  function loadGlobalMatches() {
    let d = localStorage.getItem(STORAGE_KEY);
    if (!d) return {};
    try {
      return JSON.parse(d);
    } catch {
      return {};
    }
  }

  // Refresh the matches list UI
  function refreshMatchesList() {
    matchesContainer.innerHTML = '';
    let any = false;
    Object.values(matches).forEach(m => {
      if (m.mode !== 'pvp' || m.status !== 'waiting') return;
      if (isInMatch && gameId === m.id) return; // hide your own current match

      any = true;
      const div = document.createElement('div');
      div.className = 'matchItem';

      const infoDiv = document.createElement('div');
      infoDiv.className = 'playerInfo';

      const avatar = document.createElement('div');
      avatar.className = 'avatar-circle';

      if (m.creatorAvatarUrl && m.creatorAvatarUrl.startsWith('http')) {
        const img = document.createElement('img');
        img.src = m.creatorAvatarUrl;
        img.alt = m.creatorName;
        avatar.appendChild(img);
      } else {
        avatar.textContent = m.creatorName.charAt(0).toUpperCase();
        avatar.style.backgroundColor = getAvatarColor(m.creatorName);
      }

      const nameSpan = document.createElement('span');
      nameSpan.textContent = m.creatorName;

      infoDiv.appendChild(avatar);
      infoDiv.appendChild(nameSpan);

      const btn = document.createElement('button');
      btn.textContent = 'Join';
      btn.disabled = isInMatch;
      btn.onclick = () => joinMatch(m.id);

      div.appendChild(infoDiv);
      div.appendChild(btn);

      matchesContainer.appendChild(div);
    });

    if (!any) {
      matchesContainer.innerHTML = '<div class="no-matches" style="text-align:center;color:#888;">No matches available.</div>';
    }
  }

  // Generate unique ID for matches
  function makeId() {
    return 'match_' + Math.random().toString(36).substr(2, 9);
  }

  // Update the user profile UI
  function updateUserProfile() {
    usernameSpan.textContent = currentUser.username;
    userAvatarDiv.innerHTML = '';
    if (currentUser.avatarUrl && currentUser.avatarUrl.startsWith('http')) {
      const img = document.createElement('img');
      img.src = currentUser.avatarUrl;
      img.alt = currentUser.username;
      userAvatarDiv.appendChild(img);
    } else {
      userAvatarDiv.textContent = currentUser.username.charAt(0).toUpperCase();
      userAvatarDiv.style.backgroundColor = getAvatarColor(currentUser.username);
    }
  }

  // Update UI controls state depending on if in match or not
  function updateUIForMatch() {
    let inM = isInMatch;
    createBtn.disabled = inM;
    rowSel.disabled = inM;
    colSel.disabled = inM;
    modeSel.disabled = inM;
    leaveBtn.disabled = !inM;
    canvas.style.display = inM ? 'block' : 'none';
    matchListDiv.style.display = !inM ? 'block' : 'none';
  }

  // Update status text
  function updateStatus(text) {
    statusText.textContent = text;
  }

  // Create a new match
  function createMatch() {
    if (isInMatch) return;

    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;
    gameId = makeId();
    currentPlayer = PLAYER_RED;
    myPlayer = PLAYER_RED;
    gameState = gameMode === 'pvp' ? 'waiting' : 'playing';
    initBoard();

    if (gameMode === 'pvp') {
      matches[gameId] = {
        id: gameId,
        creatorId: currentUserId,
        creatorName: currentUser.username,
        creatorAvatarUrl: currentUser.avatarUrl || '',
        rows,
        cols,
        mode: 'pvp',
        status: 'waiting',
        board: JSON.parse(JSON.stringify(board)),
        currentTurn: currentPlayer
      };
      saveGlobalMatches();
      updateStatus('Waiting for opponent to joinâ€¦');
    } else {
      updateStatus("Your turn");
    }

    isInMatch = true;
    leaveBtn.disabled = false;
    drawBoard();
    updateUIForMatch();
  }

  // Join an existing match
  function joinMatch(id) {
    if (isInMatch || !matches[id] || matches[id].status !== 'waiting') return;
    const m = matches[id];
    if (m.creatorId === currentUserId) return; // Cannot join your own match

    gameId = id;
    rows = m.rows;
    cols = m.cols;
    board = JSON.parse(JSON.stringify(m.board));
    currentPlayer = PLAYER_RED; // Owner's turn first
    myPlayer = PLAYER_YELLOW;
    gameState = 'playing';

    m.status = 'playing';
    m.opponentId = currentUserId;
    m.opponentName = currentUser.username;
    m.opponentAvatarUrl = currentUser.avatarUrl || '';
    m.board = board;
    m.currentTurn = currentPlayer;

    saveGlobalMatches();
    isInMatch = true;
    leaveBtn.disabled = false;
    drawBoard();
    updateUIForMatch();
    updateStatus("Game started! Owner's turn.");
  }

  // Leave the current match
  function leaveMatch() {
    if (!isInMatch) return;
    if (gameMode === 'pvp' && gameId && matches[gameId]) {
      delete matches[gameId];
      saveGlobalMatches();
    }
    isInMatch = false;
    gameState = 'idle';
    myPlayer = PLAYER_NONE;
    gameId = null;
    board = [];
    updateStatus('Left the match.');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateUIForMatch();
  }

  // Handle player clicking on canvas to make a move
  canvas.onclick = e => {
    if (gameState !== 'playing' || !isInMatch) return;
    if (gameMode === 'pvp' && currentPlayer !== myPlayer) return;
    if (gameMode === 'ai' && currentPlayer !== myPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const col = Math.floor((e.clientX - rect.left) / 70);
    if (col < 0 || col >= cols) return;

    const row = findLowestEmptyRow(col);
    if (row === -1) return;

    board[row][col] = myPlayer;

    drawBoard();

    if (checkWin(myPlayer)) {
      updateStatus('You win!');
      gameState = 'ended';
      if (gameMode === 'pvp' && gameId && matches[gameId]) {
        delete matches[gameId];
        saveGlobalMatches();
      }
      return;
    }

    if (checkDraw()) {
      updateStatus("It's a draw!");
      gameState = 'ended';
      if (gameMode === 'pvp' && gameId && matches[gameId]) {
        delete matches[gameId];
        saveGlobalMatches();
      }
      return;
    }

    // Switch turn
    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;

    if (gameMode === 'pvp' && gameId && matches[gameId]) {
      matches[gameId].board = JSON.parse(JSON.stringify(board));
      matches[gameId].currentTurn = currentPlayer;
      saveGlobalMatches();
      updateStatus(`Turn: ${currentPlayer === PLAYER_RED ? 'Red (Owner)' : 'Yellow (You)'}`);
    } else if (gameMode === 'ai') {
      updateStatus(`Turn: ${currentPlayer === PLAYER_RED ? 'Red (You)' : 'Yellow (AI)'}`);
      if (currentPlayer === PLAYER_YELLOW) {
        setTimeout(aiMove, 700);
      }
    }
  };

  // AI move for PvAI mode
  function aiMove() {
    if (gameState !== 'playing') return;
    let validCols = [];
    for (let c = 0; c < cols; c++) {
      if (findLowestEmptyRow(c) !== -1) validCols.push(c);
    }
    if (validCols.length === 0) return;
    let col = validCols[Math.floor(Math.random() * validCols.length)];
    let row = findLowestEmptyRow(col);
    board[row][col] = PLAYER_YELLOW;
    drawBoard();

    if (checkWin(PLAYER_YELLOW)) {
      updateStatus('AI wins!');
      gameState = 'ended';
      return;
    }
    if (checkDraw()) {
      updateStatus("It's a draw!");
      gameState = 'ended';
      return;
    }

    currentPlayer = PLAYER_RED;
    updateStatus('Your turn');
  }

  // Fill row and column selectors with options
  function populateSelectors() {
    for (let i = 4; i <= 10; i++) {
      let optRow = document.createElement('option');
      optRow.value = i;
      optRow.textContent = i;
      rowSel.appendChild(optRow);

      let optCol = document.createElement('option');
      optCol.value = i;
      optCol.textContent = i;
      colSel.appendChild(optCol);
    }
    rowSel.value = rows;
    colSel.value = cols;
  }

  // Generate a simple userId based on username + random number
  function generateUserId(name) {
    return 'user_' + name.toLowerCase().replace(/\s+/g, '') + '_' + Math.floor(Math.random() * 10000);
  }

  // Set up user on start
  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim().length < 2;
  });

  usernameSubmit.onclick = () => {
    const username = usernameInput.value.trim();
    const avatarUrl = avatarUrlInput.value.trim();

    currentUser.username = username;
    currentUser.avatarUrl = avatarUrl || null;
    currentUserId = generateUserId(username);

    updateUserProfile();
    promptContainer.style.display = 'none';
    header.style.display = 'flex';
    matchListDiv.style.display = 'block';
    refreshMatchesList();
    updateUIForMatch();
    updateStatus('Welcome, ' + username + '!');

    populateSelectors();
  };

  // Create and leave buttons
  createBtn.onclick = () => {
    createMatch();
    refreshMatchesList();
  };
  leaveBtn.onclick = () => {
    leaveMatch();
    refreshMatchesList();
  };

  // Refresh matches button
  refreshBtn.onclick = () => {
    Object.assign(matches, loadGlobalMatches());
    refreshMatchesList();
  };

  // Storage event to sync matches across tabs/windows
  window.addEventListener('storage', e => {
    if (e.key === STORAGE_KEY) {
      Object.assign(matches, loadGlobalMatches());
      refreshMatchesList();
    }
  });

  // Initial setup
  populateSelectors();

})();
</script>
</body>
</html>
