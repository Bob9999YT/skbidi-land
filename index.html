<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  body { background:#1e1e2f; color:#fff; font-family:'Segoe UI',sans-serif; margin:0; padding:20px; display:flex; align-items:center; justify-content:center; }
  #gameContainer { background:#ffcc00; border-radius:18px; padding:20px; width:460px; box-shadow:0 0 10px #ffcc00cc; }
  h1 { color:#222; text-align:center; }
  #canvas { display:none; margin:0 auto; border-radius:12px; border:3px solid #aa8800; background:#222244; cursor:pointer; }
  #status { text-align:center; font-weight:700; color:#442200; min-height:24px; margin:10px 0; }
  #matchList { display:none; background:#ffeeaa; border-radius:12px; padding:10px; max-height:260px; overflow-y:auto; color:#442200; font-weight:700; margin:10px 0; }
  .matchItem { display:flex; justify-content:space-between; align-items:center; border-bottom:2px solid #aa8800; padding:6px 0; }
  .matchPlayer { display:flex; align-items:center; gap:12px; }
  .avatar-circle { width:36px; height:36px; border-radius:50%; background:#aa8800; color:#222; font-weight:900; font-size:18px; display:flex; align-items:center; justify-content:center; }
  button { background:#aa8800; border:none; padding:8px 14px; border-radius:14px; font-weight:900; color:#fff; cursor:pointer; margin:4px 0; transition:background-color .2s; }
  button:hover:not(:disabled) { background:#ddb300; }
  button:disabled { background:#665500; cursor:not-allowed; }
  #usernameInput { width:100%; padding:8px; border-radius:14px; border:none; margin-bottom:10px; font-size:18px; font-weight:700; }
  #menu { display:none; text-align:center; margin:10px 0; }
  #modeSelect { padding:6px 14px; border-radius:14px; border:none; font-weight:700; }
  #aiDifficultyButtons { display:none; margin:10px 0; gap:10px; }
  #aiDifficultyButtons button { font-size:14px; border-radius:12px; padding:6px 10px; }
  #aiDifficultyButtons button.active { background:#ddb300; color:#222; }
  #profileDisplay { text-align:center; font-weight:900; color:#442200; margin-bottom:10px; }
  #refreshMatchesBtn { width:100%; margin-top:10px; }
</style>
</head>
<body>
<div id="gameContainer">
  <h1>Connect Four</h1>
  <div id="usernamePrompt">
    <input id="usernameInput" placeholder="Enter username"/>
    <button id="usernameSubmit" disabled>Start</button>
  </div>
  <div id="profileDisplay"></div>
  <div id="menu">
    <select id="modeSelect">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>
    <div id="aiDifficultyButtons">
      <button data-level="easy">Easy</button>
      <button data-level="normal" class="active">Normal</button>
      <button data-level="hard">Hard</button>
      <button data-level="insane">Insane</button>
      <button data-level="impossible">Impossible</button>
    </div>
    <button id="createMatchBtn">Create Match</button>
    <button id="leaveMatchBtn" disabled>Leave Match</button>
    <button id="refreshMatchesBtn">ðŸ”„ Refresh Matches</button>
  </div>
  <div id="status"></div>
  <div id="matchList"></div>
  <canvas id="canvas" width="420" height="360"></canvas>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
(function initializeGame() {
  // Firebase config
  const config = {
    apiKey: "AIzaSyCKSyN1gTe8XvveVnDV8VzXLieaPGsQBc8",
    authDomain: "sigma-skibidi-b9e1e.firebaseapp.com",
    databaseURL: "https://sigma-skibidi-b9e1e-default-rtdb.firebaseio.com",
    projectId: "sigma-skibidi-b9e1e",
    storageBucket: "sigma-skibidi-b9e1e.appspot.com",
    messagingSenderId: "645635975542",
    appId: "1:645635975542:web:f22275c0e2b9ae00f8b257",
    measurementId: "G-G7DX318MFR"
  };
  firebase.initializeApp(config);
  const db = firebase.database();

  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const ROWS = 6, COLS = 7;
  const board = Array.from({ length: ROWS }, () => Array(COLS).fill(PLAYER_NONE));

  let currentUser = { id: null, username: null };
  let mode = 'pvp', aiLevel = 'normal';
  let myPl = PLAYER_NONE, currPl = PLAYER_RED;
  let matchId = null, inMatch = false;

  const el = id => document.getElementById(id);
  const usernamePrompt = el('usernamePrompt');
  const usernameInput = el('usernameInput');
  const usernameSubmit = el('usernameSubmit');
  const profileDisplay = el('profileDisplay');
  const menu = el('menu');
  const canvas = el('canvas');
  const ctx = canvas.getContext('2d');
  const statusDiv = el('status');
  const matchListDiv = el('matchList');

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cell = canvas.width / COLS;
    ctx.fillStyle = '#222244';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = c * cell, y = r * cell;
        ctx.beginPath();
        ctx.fillStyle = '#555577';
        ctx.arc(x + cell/2, y + cell/2, cell/2 - 6, 0, 2*Math.PI);
        ctx.fill();
        if (board[r][c] !== PLAYER_NONE) {
          ctx.beginPath();
          ctx.fillStyle = board[r][c] === PLAYER_RED ? '#ff5555' : '#ffff77';
          ctx.arc(x + cell/2, y + cell/2, cell/2 - 12, 0, 2*Math.PI);
          ctx.fill();
        }
      }
    }
  }

  function placePiece(col, player) {
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r][col] === PLAYER_NONE) {
        board[r][col] = player;
        return r;
      }
    }
    return -1;
  }

  function checkWin(player) {
    const dirs = [[0,1],[1,0],[1,1],[1,-1]];
    const inbound = (r, c) => r>=0 && r<ROWS && c>=0 && c<COLS;
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        if (board[r][c] === player) {
          for (let [dr, dc] of dirs) {
            let count = 1;
            for (let i=1; i<4; i++) {
              const nr = r + dr*i, nc = c + dc*i;
              if (!inbound(nr, nc) || board[nr][nc] !== player) break;
              count++;
            }
            if (count >= 4) return true;
          }
        }
      }
    }
    return false;
  }

  function isBoardFull() {
    return board[0].every(cell => cell !== PLAYER_NONE);
  }

  function switchTurn() {
    currPl = (currPl === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED);
  }

  function resetGame() {
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        board[r][c] = PLAYER_NONE;
      }
    }
    draw();
    canvas.style.display = 'none';
    el('leaveMatchBtn').disabled = true;
    inMatch = false;
    currPl = PLAYER_RED;
    myPl = PLAYER_NONE;
    matchId = null;
    statusDiv.textContent = '';
    updateMatchList();
  }

  function sendUpdate() {
    if (!matchId) return;
    db.ref(`matches/${matchId}`).update({ board, currPl, status: 'playing' });
  }

  function createMatch() {
    if (inMatch) return alert('Already in a game!');
    resetGame();
    canvas.style.display = 'block';
    el('leaveMatchBtn').disabled = false;
    inMatch = true;
    myPl = PLAYER_RED;
    currPl = PLAYER_RED;
    const ref = db.ref('matches').push();
    matchId = ref.key;
    const data = {
      owner: currentUser,
      board,
      currPl,
      status: 'waiting',
      mode
    };
    ref.set(data);
    listenToMatch();
    statusDiv.textContent = 'Waiting for opponent...';
    updateMatchList();
  }

  function joinMatch(id) {
    if (inMatch) return alert('Already in a game!');
    const ref = db.ref(`matches/${id}`);
    ref.once('value', snap => {
      const m = snap.val();
      if (!m || m.status !== 'waiting') return alert('Not available');
      ref.update({ opponent: currentUser, status: 'playing' });
      inMatch = true;
      myPl = PLAYER_YELLOW;
      currPl = m.currPl;
      canvas.style.display = 'block';
      el('leaveMatchBtn').disabled = false;
      listenToMatch();
      statusDiv.textContent = "Your turn";
    });
  }

  function listenToMatch() {
    const ref = db.ref(`matches/${matchId}`);
    ref.on('value', snap => {
      const m = snap.val();
      if (!m) {
        resetGame();
        return;
      }
      m.board.forEach((row, r) => row.forEach((v, c) => { board[r][c] = v; }));
      currPl = m.currPl;
      draw();
      if (m.status === 'waiting') {
        statusDiv.textContent = (myPl === PLAYER_RED ? 'Waiting for opponent...' : 'Joined â€” waiting...');
      } else {
        statusDiv.textContent = (currPl === myPl ? 'Your turn' : "Opponent's turn");
      }
      updateMatchList();
    });
  }

  function leaveMatch() {
    if (!matchId) return;
    const ref = db.ref(`matches/${matchId}`);
    ref.once('value', snap => {
      const m = snap.val();
      if (m.owner.id === currentUser.id) {
        ref.remove();
      } else if (m.opponent) {
        ref.update({ opponent: null, status: 'waiting' });
      }
    });
    resetGame();
  }

  function updateMatchList() {
    if (mode !== 'pvp') {
      matchListDiv.style.display = 'none';
      return;
    }
    matchListDiv.style.display = 'block';
    matchListDiv.innerHTML = '<strong>Available matches:</strong><br>';
    db.ref('matches').once('value', snap => {
      const all = snap.val() || {};
      matchListDiv.innerHTML = '<strong>Available matches:</strong><br>';
      Object.entries(all).forEach(([id, m]) => {
        if (m.status === 'waiting' && m.owner.id !== currentUser.id) {
          const div = document.createElement('div');
          div.className = 'matchItem';
          div.innerHTML = `
            <div class="matchPlayer">
              <div class="avatar-circle">${m.owner.username[0]}</div>
              <span>${m.owner.username}</span>
            </div>
            <button>Join</button>
          `;
          div.querySelector('button').onclick = () => joinMatch(id);
          matchListDiv.appendChild(div);
        }
      });
    });
  }

  // UI Events
  usernameInput.oninput = () => usernameSubmit.disabled = !usernameInput.value.trim();
  usernameSubmit.onclick = () => {
    currentUser.username = usernameInput.value.trim();
    currentUser.id = 'u' + Math.random().toString(36).substr(2,9);
    usernamePrompt.style.display = 'none';
    profileDisplay.textContent = `Logged in as: ${currentUser.username}`;
    el('menu').style.display = 'block';
    updateMatchList();
  };

  el('modeSelect').onchange = e => {
    mode = e.target.value;
    el('aiDifficultyButtons').style.display = (mode === 'ai' ? 'flex' : 'none');
    resetGame();
    updateMatchList();
  };

  document.querySelectorAll('#aiDifficultyButtons button').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('#aiDifficultyButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiLevel = btn.dataset.level;
    };
  });

  el('createMatchBtn').onclick = createMatch;
  el('leaveMatchBtn').onclick = leaveMatch;
  el('refreshMatchesBtn').onclick = updateMatchList;

  canvas.onclick = e => {
    if (!inMatch || currPl !== myPl) return;
    const rect = canvas.getBoundingClientRect();
    const col = Math.floor((e.clientX - rect.left) / (canvas.width / COLS));
    const r = placePiece(col, myPl);
    if (r < 0) return;
    draw();

    if (checkWin(myPl)) {
      statusDiv.textContent = 'You win!';
      leaveMatch();
      return;
    }
    if (isBoardFull()) {
      statusDiv.textContent = 'Draw!';
      leaveMatch();
      return;
    }
    switchTurn();
    if (mode === 'pvp') {
      sendUpdate();
    } else {
      statusDiv.textContent = "AI's turn";
      setTimeout(() => {
        const col2 = Math.floor(Math.random() * COLS);
        placePiece(col2, PLAYER_YELLOW);
        draw();
        if (checkWin(PLAYER_YELLOW)) {
          statusDiv.textContent = 'AI wins!';
          leaveMatch();
        } else if (isBoardFull()) {
          statusDiv.textContent = 'Draw!';
          leaveMatch();
        } else {
          switchTurn();
          statusDiv.textContent = 'Your turn';
        }
      }, 500);
    }
  };

  draw();
})();
</script>
</body>
</html>
