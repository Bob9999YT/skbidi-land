<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin-bottom: 1rem;
    text-align: center;
  }
  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 16px;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover {
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  button:disabled:hover {
    transform: none;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .matchItem .playerInfo img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
  }
  .matchItem button:hover {
    transform: scale(1.1);
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
</style>
</head>
<body>
  <h1>Connect Four</h1>

  <div class="menu">
    <label for="rows">Rows:</label>
    <select id="rows" name="rows"></select>

    <label for="cols">Columns:</label>
    <select id="cols" name="cols"></select>

    <label for="mode">Mode:</label>
    <select id="mode" name="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>

    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420"></canvas>
  <div id="status">Click "Create Game" to start playing!</div>

  <div id="matchList">
    <h3>Available Matches</h3>
    <div id="matchesContainer">No matches available.</div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';
  let matches = {}; // id -> game object
  let discordUser = null;

  // Initialize Discord SDK
  async function initDiscord() {
    if (typeof DiscordSDK !== "undefined") {
      try {
        await DiscordSDK.ready();
        
        // Get current user info
        const auth = await DiscordSDK.commands.authenticate({
          access_token: await DiscordSDK.commands.authorize({
            client_id: DiscordSDK.clientId,
            response_type: "code",
            state: "",
            prompt: "none",
            scope: ["identify", "guilds"]
          })
        });
        
        discordUser = auth.user;
        console.log("Discord user:", discordUser);
        
        // Set up activity participants sync
        DiscordSDK.subscribe('ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE', (data) => {
          console.log("Participants updated:", data);
          // Sync matches with participants
          syncMatchesWithParticipants(data.participants);
        });
        
        renderMatchList();
      } catch (error) {
        console.error("Discord initialization failed:", error);
        // Fallback to local user
        discordUser = {
          id: 'local_' + Math.random().toString(36).substr(2, 9),
          username: 'Local Player',
          avatar: null
        };
      }
    } else {
      // Fallback for non-Discord environment
      discordUser = {
        id: 'local_' + Math.random().toString(36).substr(2, 9),
        username: 'Local Player',
        avatar: null
      };
    }
  }

  function syncMatchesWithParticipants(participants) {
    // Update matches based on active participants
    // This helps sync matches across different users in the activity
    const participantIds = participants.map(p => p.id);
    
    // Remove matches from users who are no longer in the activity
    Object.keys(matches).forEach(matchId => {
      if (!participantIds.includes(matches[matchId].ownerId)) {
        delete matches[matchId];
      }
    });
    
    renderMatchList();
  }

  function setupUI() {
    // Populate dropdown options
    for(let i=4; i<=10; i++) {
      const rowOption = new Option(i, i);
      const colOption = new Option(i, i);
      rowSel.add(rowOption);
      colSel.add(colOption);
    }
    rowSel.value = rows;
    colSel.value = cols;

    // Event listeners
    rowSel.addEventListener('change', () => { 
      rows = parseInt(rowSel.value); 
      updateCanvasSize(); 
    });
    colSel.addEventListener('change', () => { 
      cols = parseInt(colSel.value); 
      updateCanvasSize(); 
    });
    modeSel.addEventListener('change', () => {
      gameMode = modeSel.value;
      toggleAIDifficulty(gameMode === 'ai');
    });

    createBtn.addEventListener('click', onCreate);
    leaveBtn.addEventListener('click', onLeave);
    canvas.addEventListener('click', onClick);

    aiButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        aiButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.getAttribute('data-level');
        setStatus(`AI difficulty set to ${aiDifficulty}`);
      });
    });

    toggleAIDifficulty(false);
    updateUIButtons();
    renderMatchList();
  }

  function toggleAIDifficulty(show) {
    aiDifficultyDiv.style.display = show ? 'flex' : 'none';
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    if (board.length > 0) {
      drawBoard();
    }
  }

  function setStatus(text) {
    statusText.textContent = text;
  }

  function updateUIButtons() {
    const isGameActive = gameState === 'playing' || gameState === 'waiting' || gameState === 'ended';
    leaveBtn.disabled = !isGameActive;
    createBtn.disabled = gameState === 'playing' || gameState === 'waiting';
    
    // Disable controls during active game
    rowSel.disabled = isGameActive;
    colSel.disabled = isGameActive;
    modeSel.disabled = isGameActive;
  }

  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        let color = "white";
        if (board[y][x] === PLAYER_RED) color = "#f44336";
        else if (board[y][x] === PLAYER_YELLOW) color = "#fdd835";
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(35 + x*70, 35 + y*70, 30, 0, 2*Math.PI);
        ctx.fill();
        
        // Add border to pieces
        if (board[y][x] !== PLAYER_NONE) {
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }
  }

  function onCreate() {
    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;

    initBoard();
    gameId = 'game_' + Math.random().toString(36).substr(2,8);

    currentGame = {
      id: gameId,
      rows,
      cols,
      mode: gameMode,
      difficulty: aiDifficulty,
      state: gameMode === 'ai' ? 'playing' : 'waiting',
      ownerId: discordUser ? discordUser.id : 'local_player',
      ownerName: discordUser ? discordUser.username : 'Local Player',
      ownerAvatar: discordUser ? discordUser.avatar : null,
      players: [discordUser ? discordUser.id : 'local_player'],
    };

    myPlayer = PLAYER_RED;
    currentPlayer = PLAYER_RED;
    gameState = currentGame.state;

    if(gameMode === 'ai'){
      setStatus("Your turn! Click a column to drop your piece.");
      toggleMatchList(false);
    } else {
      setStatus("Waiting for opponent to join...");
      toggleMatchList(true);
      addMatch(currentGame);
    }
    
    updateUIButtons();
    broadcast({ type: 'create', game: currentGame });
  }

  function onJoinGame(id) {
    if (!matches[id]) {
      setStatus("Match not found.");
      return;
    }
    currentGame = matches[id];
    rows = currentGame.rows;
    cols = currentGame.cols;
    gameId = currentGame.id;
    gameMode = currentGame.mode;
    aiDifficulty = currentGame.difficulty || 'normal';
    myPlayer = PLAYER_YELLOW;
    currentPlayer = PLAYER_RED;

    initBoard();

    gameState = 'playing';
    setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
    toggleMatchList(false);
    updateUIButtons();

    broadcast({ type: 'join', gameId });
  }

  function onLeave() {
    if(!currentGame) return;
    
    broadcast({ type: 'leave', gameId, ownerLeft: true });
    delete matches[gameId];
    resetGame();
    toggleMatchList(true);
    renderMatchList();
    setStatus("Game ended.");
  }

  function resetGame() {
    gameState = 'idle';
    currentGame = null;
    board = [];
    myPlayer = PLAYER_NONE;
    gameId = null;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    setStatus("Click \"Create Game\" to start playing!");
    updateUIButtons();
  }

  function isBoardFull() {
    return board.every(row => row.every(cell => cell !== PLAYER_NONE));
  }

  function checkWin() {
    // Horizontal check
    for(let y=0; y<rows; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y][x+1] && val === board[y][x+2] && val === board[y][x+3]){
          return val;
        }
      }
    }
    // Vertical check
    for(let x=0; x<cols; x++){
      for(let y=0; y<=rows-4; y++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y+1][x] && val === board[y+2][x] && val === board[y+3][x]){
          return val;
        }
      }
    }
    // Diagonal down-right
    for(let y=0; y<=rows-4; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y+1][x+1] && val === board[y+2][x+2] && val === board[y+3][x+3]){
          return val;
        }
      }
    }
    // Diagonal up-right
    for(let y=3; y<rows; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y-1][x+1] && val === board[y-2][x+2] && val === board[y-3][x+3]){
          return val;
        }
      }
    }
    return PLAYER_NONE;
  }

  function onClick(e) {
    if(gameState !== 'playing') return;
    if(myPlayer !== currentPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const xClick = e.clientX - rect.left;
    const col = Math.floor(xClick / 70);
    if(col < 0 || col >= cols) return;

    // Check if column is full
    if(board[0][col] !== PLAYER_NONE) return;

    // Find the lowest available row
    for(let y=rows-1; y>=0; y--){
      if(board[y][col] === PLAYER_NONE){
        board[y][col] = myPlayer;
        drawBoard();
        broadcast({type:'move', col, row:y, player: myPlayer, gameId});

        const winner = checkWin();
        if(winner !== PLAYER_NONE){
          gameState = 'ended';
          setStatus(winner === myPlayer ? "You win!" : "You lose!");
          broadcast({type:'end', winner, gameId});
        } else if(isBoardFull()){
          gameState = 'ended';
          setStatus("It's a draw!");
          broadcast({type:'end', winner: PLAYER_NONE, gameId});
        } else {
          currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
          setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
          if(gameMode === 'ai' && currentPlayer !== myPlayer){
            setTimeout(aiMove, 500);
          }
        }
        updateUIButtons();
        break;
      }
    }
  }

  function aiMove() {
  if(gameState !== 'playing') return;
  if(currentPlayer !== PLAYER_YELLOW) return; // AI plays yellow

  let chosenCol;
  
  switch(aiDifficulty) {
    case 'easy':
      chosenCol = getRandomMove();
      break;
    case 'normal':
      chosenCol = getNormalMove();
      break;
    case 'hard':
      chosenCol = getHardMove();
      break;
    case 'insane':
      chosenCol = getInsaneMove();
      break;
    case 'impossible':
      chosenCol = getImpossibleMove();
      break;
    default:
      chosenCol = getRandomMove();
  }
  
  if (chosenCol === -1) return;
  
  // Place the piece
  for(let y=rows-1; y>=0; y--){
    if(board[y][chosenCol] === PLAYER_NONE){
      board[y][chosenCol] = PLAYER_YELLOW;
      drawBoard();
      broadcast({type:'move', col:chosenCol, row:y, player: PLAYER_YELLOW, gameId});

      const winner = checkWin();
      if(winner !== PLAYER_NONE){
        gameState = 'ended';
        setStatus(winner === PLAYER_YELLOW ? "AI wins!" : "You win!");
        broadcast({type:'end', winner, gameId});
      } else if(isBoardFull()){
        gameState = 'ended';
        setStatus("It's a draw!");
        broadcast({type:'end', winner: PLAYER_NONE, gameId});
      } else {
        currentPlayer = PLAYER_RED;
        setStatus("Your turn!");
      }
      updateUIButtons();
      break;
    }
  }
}

// AI Helper Functions (add these new functions)
function getRandomMove() {
  const possibleCols = [];
  for(let c=0; c<cols; c++){
    if(board[0][c] === PLAYER_NONE){
      possibleCols.push(c);
    }
  }
  return possibleCols.length > 0 ? possibleCols[Math.floor(Math.random() * possibleCols.length)] : -1;
}

function getNormalMove() {
  // Check for winning move first
  for(let c=0; c<cols; c++){
    if(board[0][c] === PLAYER_NONE){
      const tempBoard = board.map(row => [...row]);
      for(let y=rows-1; y>=0; y--){
        if(tempBoard[y][c] === PLAYER_NONE){
          tempBoard[y][c] = PLAYER_YELLOW;
          if(checkWinOnBoard(tempBoard) === PLAYER_YELLOW){
            return c;
          }
          break;
        }
      }
    }
  }
  
  // Check for blocking move
  for(let c=0; c<cols; c++){
    if(board[0][c] === PLAYER_NONE){
      const tempBoard = board.map(row => [...row]);
      for(let y=rows-1; y>=0; y--){
        if(tempBoard[y][c] === PLAYER_NONE){
          tempBoard[y][c] = PLAYER_RED;
          if(checkWinOnBoard(tempBoard) === PLAYER_RED){
            return c;
          }
          break;
        }
      }
    }
  }
  
  // Otherwise random
  return getRandomMove();
}

function getHardMove() {
  // Use minimax with depth 4
  const move = minimax(board, 4, -Infinity, Infinity, true);
  return move.col;
}

function getInsaneMove() {
  // Use minimax with depth 6
  const move = minimax(board, 6, -Infinity, Infinity, true);
  return move.col;
}

function getImpossibleMove() {
  // Use minimax with depth 8 and enhanced evaluation
  const move = minimax(board, 8, -Infinity, Infinity, true);
  return move.col;
}

function minimax(board, depth, alpha, beta, isMaximizing) {
  const winner = checkWinOnBoard(board);
  
  if (winner === PLAYER_YELLOW) return { score: 100000 };
  if (winner === PLAYER_RED) return { score: -100000 };
  if (depth === 0 || isBoardFullOnBoard(board)) return { score: evaluateBoard(board) };
  
  if (isMaximizing) {
    let maxEval = -Infinity;
    let bestCol = -1;
    
    for (let c = 0; c < cols; c++) {
      if (board[0][c] === PLAYER_NONE) {
        const newBoard = makeMove(board, c, PLAYER_YELLOW);
        const eval = minimax(newBoard, depth - 1, alpha, beta, false);
        
        if (eval.score > maxEval) {
          maxEval = eval.score;
          bestCol = c;
        }
        
        alpha = Math.max(alpha, eval.score);
        if (beta <= alpha) break;
      }
    }
    
    return { score: maxEval, col: bestCol };
  } else {
    let minEval = Infinity;
    let bestCol = -1;
    
    for (let c = 0; c < cols; c++) {
      if (board[0][c] === PLAYER_NONE) {
        const newBoard = makeMove(board, c, PLAYER_RED);
        const eval = minimax(newBoard, depth - 1, alpha, beta, true);
        
        if (eval.score < minEval) {
          minEval = eval.score;
          bestCol = c;
        }
        
        beta = Math.min(beta, eval.score);
        if (beta <= alpha) break;
      }
    }
    
    return { score: minEval, col: bestCol };
  }
}

function makeMove(board, col, player) {
  const newBoard = board.map(row => [...row]);
  for (let y = rows - 1; y >= 0; y--) {
    if (newBoard[y][col] === PLAYER_NONE) {
      newBoard[y][col] = player;
      break;
    }
  }
  return newBoard;
}

function evaluateBoard(board) {
  let score = 0;
  
  // Center column preference
  const centerCol = Math.floor(cols / 2);
  for (let y = 0; y < rows; y++) {
    if (board[y][centerCol] === PLAYER_YELLOW) score += 3;
    if (board[y][centerCol] === PLAYER_RED) score -= 3;
  }
  
  // Evaluate all possible 4-in-a-row windows
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      // Horizontal
      if (x <= cols - 4) {
        score += evaluateWindow([board[y][x], board[y][x+1], board[y][x+2], board[y][x+3]]);
      }
      // Vertical
      if (y <= rows - 4) {
        score += evaluateWindow([board[y][x], board[y+1][x], board[y+2][x], board[y+3][x]]);
      }
      // Diagonal \
      if (y <= rows - 4 && x <= cols - 4) {
        score += evaluateWindow([board[y][x], board[y+1][x+1], board[y+2][x+2], board[y+3][x+3]]);
      }
      // Diagonal /
      if (y >= 3 && x <= cols - 4) {
        score += evaluateWindow([board[y][x], board[y-1][x+1], board[y-2][x+2], board[y-3][x+3]]);
      }
    }
  }
  
  return score;
}

function evaluateWindow(window) {
  let score = 0;
  const aiCount = window.filter(cell => cell === PLAYER_YELLOW).length;
  const humanCount = window.filter(cell => cell === PLAYER_RED).length;
  const emptyCount = window.filter(cell => cell === PLAYER_NONE).length;
  
  if (aiCount === 4) score += 100;
  else if (aiCount === 3 && emptyCount === 1) score += 10;
  else if (aiCount === 2 && emptyCount === 2) score += 2;
  
  if (humanCount === 4) score -= 100;
  else if (humanCount === 3 && emptyCount === 1) score -= 80;
  else if (humanCount === 2 && emptyCount === 2) score -= 2;
  
  return score;
}

function checkWinOnBoard(board) {
  // Same logic as checkWin() but for any board state
  for(let y=0; y<rows; y++){
    for(let x=0; x<=cols-4; x++){
      const val = board[y][x];
      if(val !== PLAYER_NONE && val === board[y][x+1] && val === board[y][x+2] && val === board[y][x+3]){
        return val;
      }
    }
  }
  for(let x=0; x<cols; x++){
    for(let y=0; y<=rows-4; y++){
      const val = board[y][x];
      if(val !== PLAYER_NONE && val === board[y+1][x] && val === board[y+2][x] && val === board[y+3][x]){
        return val;
      }
    }
  }
  for(let y=0; y<=rows-4; y++){
    for(let x=0; x<=cols-4; x++){
      const val = board[y][x];
      if(val !== PLAYER_NONE && val === board[y+1][x+1] && val === board[y+2][x+2] && val === board[y+3][x+3]){
        return val;
      }
    }
  }
  for(let y=3; y<rows; y++){
    for(let x=0; x<=cols-4; x++){
      const val = board[y][x];
      if(val !== PLAYER_NONE && val === board[y-1][x+1] && val === board[y-2][x+2] && val === board[y-3][x+3]){
        return val;
      }
    }
  }
  return PLAYER_NONE;
}

function isBoardFullOnBoard(board) {
  return board.every(row => row.every(cell => cell !== PLAYER_NONE));
}

  function addMatch(game) {
    matches[game.id] = game;
    renderMatchList();
  }

  function renderMatchList() {
    matchesContainer.innerHTML = '';

    const userId = discordUser ? discordUser.id : 'local_player';
    const visibleMatches = Object.values(matches).filter(m => m.ownerId !== userId);

    if(visibleMatches.length === 0) {
      matchesContainer.textContent = "No matches available.";
      return;
    }

    for(let match of visibleMatches){
      const div = document.createElement('div');
      div.className = 'matchItem';

      const playerInfo = document.createElement('div');
      playerInfo.className = 'playerInfo';
      
      // Add avatar if available
      if(match.ownerAvatar) {
        const img = document.createElement('img');
        img.src = `https://cdn.discordapp.com/avatars/${match.ownerId}/${match.ownerAvatar}.png?size=64`;
        img.onerror = () => { 
          img.src = `https://cdn.discordapp.com/embed/avatars/${parseInt(match.ownerId) % 5}.png`; 
        };
        playerInfo.appendChild(img);
      }

      const matchDetails = document.createElement('div');
      matchDetails.innerHTML = `
        <div style="font-weight: bold;">${match.ownerName || 'Unknown Player'}</div>
        <div style="font-size: 0.9em; opacity: 0.8;">${match.rows}×${match.cols} • ${match.mode.toUpperCase()}</div>
      `;
      playerInfo.appendChild(matchDetails);

      div.appendChild(playerInfo);

      const joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';
      joinBtn.addEventListener('click', () => {
        onJoinGame(match.id);
      });
      div.appendChild(joinBtn);

      matchesContainer.appendChild(div);
    }
  }

  function toggleMatchList(show) {
    document.getElementById('matchList').style.display = show ? 'block' : 'none';
  }

 function setupDiscordListeners() {
  if (typeof DiscordSDK !== "undefined") {
    // Listen for activity instance data updates
    DiscordSDK.subscribe('ACTIVITY_INSTANCE_DATA_UPDATE', (data) => {
      console.log("Activity instance data updated:", data);
      if (data.type === 'MATCH_UPDATE' && data.data) {
        const remoteMatches = data.data.matches;
        const userId = discordUser ? discordUser.id : 'local_player';
        
        // Merge remote matches with local matches
        Object.keys(remoteMatches).forEach(matchId => {
          if (remoteMatches[matchId].ownerId !== userId) {
            matches[matchId] = remoteMatches[matchId];
          }
        });
        
        renderMatchList();
      }
    });

    // Periodic refresh of matches from activity participants
    setInterval(() => {
      if (gameState === 'idle' || gameState === 'waiting') {
        DiscordSDK.commands.getActivityInstanceData()
          .then(data => {
            if (data && data.matches) {
              const remoteMatches = JSON.parse(data.matches);
              const userId = discordUser ? discordUser.id : 'local_player';
              
              Object.keys(remoteMatches).forEach(matchId => {
                if (remoteMatches[matchId].ownerId !== userId) {
                  matches[matchId] = remoteMatches[matchId];
                }
              });
              
              renderMatchList();
            }
          })
          .catch(err => console.log("No activity instance data:", err));
      }
    }, 3000); // Refresh every 3 seconds
  }
}

 function broadcast(msg) {
  // For Discord activities, use the instance data system
  if (typeof DiscordSDK !== "undefined") {
    try {
      // Update Discord activity with current game state
      DiscordSDK.commands.setActivity({
        activity: {
          type: 0, // Playing
          details: `Connect Four ${rows}×${cols}`,
          state: gameState === 'playing' ? 'In Game' : gameState === 'waiting' ? 'Waiting' : 'Menu',
          party: {
            id: gameId || 'lobby',
            size: [Object.keys(matches).length + 1, 10]
          },
          // Store match data in activity instance
          instance: {
            matches: JSON.stringify(matches),
            timestamp: Date.now()
          }
        }
      });

      // Also send as activity message for real-time updates
      DiscordSDK.commands.sendActivityInstanceData({
        type: 'MATCH_UPDATE',
        data: {
          matches: matches,
          message: msg,
          timestamp: Date.now()
        }
      });
      
    } catch (error) {
      console.error("Discord activity update failed:", error);
    }
  }
  
  // Fallback to localStorage for non-Discord environments
  if (msg.type === 'create') {
    matches[msg.game.id] = msg.game;
  } else if (msg.type === 'leave' && msg.ownerLeft) {
    delete matches[msg.gameId];
  }
  
  // Broadcast to other tabs/instances
  window.dispatchEvent(new CustomEvent('gameMessage', {detail: msg}));
}

  // Listen for Discord activity messages
  if (typeof DiscordSDK !== "undefined") {
    DiscordSDK.subscribe('ACTIVITY_MESSAGE', (data) => {
      console.log("Received activity message:", data);
      if (data.type === 'CUSTOM' && data.data) {
        window.dispatchEvent(new CustomEvent('gameMessage', {detail: data.data}));
      }
    });
  }

  // Listen for localStorage changes (cross-tab communication)
  window.addEventListener('storage', (e) => {
    if (e.key === 'connectFourMatches') {
      const newMatches = JSON.parse(e.newValue || '{}');
      matches = newMatches;
      renderMatchList();
    }
  });

  // Load existing matches on startup
  function loadMatches() {
    try {
      const existingMatches = JSON.parse(localStorage.getItem('connectFourMatches') || '{}');
      matches = existingMatches;
      renderMatchList();
    } catch (error) {
      console.error("Failed to load matches:", error);
      matches = {};
    }
  }

  window.addEventListener('gameMessage', e => {
    const msg = e.detail;
    if(msg.gameId && msg.gameId !== gameId) return;

    switch(msg.type) {
      case 'create':
        if(msg.game.id !== gameId) {
          matches[msg.game.id] = msg.game;
          renderMatchList();
        }
        break;
      case 'join':
        if(matches[msg.gameId]) {
          matches[msg.gameId].players.push('opponent');
          matches[msg.gameId].state = 'playing';
          if(currentGame && currentGame.id === msg.gameId) {
            gameState = 'playing';
            setStatus("Opponent joined! Your turn!");
            toggleMatchList(false);
            updateUIButtons();
          }
          renderMatchList();
        }
        break;
      case 'leave':
        if(msg.ownerLeft){
          delete matches[msg.gameId];
          if(currentGame && currentGame.id === msg.gameId){
            resetGame();
            toggleMatchList(true);
          }
        }
        renderMatchList();
        break;
      case 'move':
        if(gameState !== 'playing') return;
        if(msg.player !== myPlayer) {
          board[msg.row][msg.col] = msg.player;
          drawBoard();
          currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
          setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
        }
        break;
      case 'end':
        gameState = 'ended';
        if(msg.winner === PLAYER_NONE){
          setStatus("It's a draw!");
        } else if(msg.winner === myPlayer){
          setStatus("You win!");
        } else {
          setStatus("You lose!");
        }
        updateUIButtons();
        break;
    }
  });

  // Initialize the game
  initDiscord().then(() => {
    setupUI();
    initBoard();
    updateUIButtons();
    loadMatches();
  });
});
</script>

</body>
</html>
