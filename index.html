<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four Global Multiplayer & AI</title>
<style>
  body {
    background: #1e1e2f;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    color: #ffbb33;
    margin-bottom: 10px;
    text-shadow: 0 0 8px #ffbb33aa;
  }
  #canvas {
    border-radius: 12px;
    border: 3px solid #ffbb33;
    cursor: pointer;
    margin-top: 15px;
    background: #222244;
    box-shadow: 0 0 15px #ffbb33aa inset;
    display: none;
  }
  #status {
    margin: 15px 0 5px;
    font-size: 20px;
    font-weight: 600;
    min-height: 28px;
    text-align: center;
  }
  #matchList {
    width: 360px;
    max-height: 320px;
    overflow-y: auto;
    background: #29293d;
    border-radius: 12px;
    padding: 12px 15px;
    margin-top: 20px;
    box-shadow: 0 0 20px #ffaa0044 inset;
  }
  .matchItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 8px;
    border-bottom: 1px solid #555;
    color: #ffbb33;
    font-weight: 600;
  }
  .matchPlayer {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .avatar-circle {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: #ffaa00;
    color: #222;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 18px;
    user-select: none;
    text-shadow: 0 0 2px #fff;
  }
  button {
    background: #ffaa00;
    border: none;
    color: #222;
    padding: 8px 18px;
    border-radius: 18px;
    cursor: pointer;
    font-weight: 700;
    font-size: 16px;
    box-shadow: 0 4px 8px #ffbb0077;
    transition: background-color 0.25s ease, box-shadow 0.25s ease;
    user-select: none;
  }
  button:hover:not(:disabled) {
    background-color: #ffcc33;
    box-shadow: 0 6px 12px #ffcc3399;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
    box-shadow: none;
    color: #999;
  }
  #aiDifficultyButtons button {
    margin-right: 8px;
    min-width: 80px;
    padding: 8px 14px;
    font-size: 14px;
    border-radius: 14px;
    box-shadow: 0 3px 6px #ffbb0055;
  }
  #aiDifficultyButtons button.active {
    background: #ffd24d;
    color: #222;
    font-weight: 800;
    box-shadow: 0 5px 12px #ffdd5599;
  }
  #usernameInput {
    width: 320px;
    padding: 8px 12px;
    margin-bottom: 10px;
    border-radius: 16px;
    border: none;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    outline: none;
    box-shadow: inset 0 0 8px #ffaa00cc;
    background: #29293d;
    color: #fff;
  }
  #usernameInput::placeholder {
    color: #ffaa00aa;
  }
  #menu {
    margin-top: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    justify-content: center;
  }
  #modeSelect {
    padding: 8px 12px;
    border-radius: 18px;
    border: none;
    font-size: 16px;
    font-weight: 700;
    box-shadow: 0 0 10px #ffaa00cc inset;
    background: #29293d;
    color: #ffbb33;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>Connect Four</h1>

<div id="usernamePrompt">
  <input id="usernameInput" placeholder="Enter username" autocomplete="off" />
  <button id="usernameSubmit" disabled>Start</button>
</div>

<div id="menu" style="display:none;">
  <select id="modeSelect" aria-label="Game Mode Select">
    <option value="pvp">Player vs Player</option>
    <option value="ai">Player vs AI</option>
  </select>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <button id="createMatchBtn">Create Match</button>
  <button id="leaveMatchBtn" disabled>Leave Match</button>
  <button id="refreshMatchesBtn">Refresh Matches</button>
</div>

<div id="status"></div>
<div id="matchList"></div>

<canvas id="canvas" width="420" height="360"></canvas>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
(() => {
  // Firebase config - Replace with your own!
  const firebaseConfig = {
    apiKey: "AIzaSyCKSyN1gTe8XvveVnDV8VzXLieaPGsQBc8",
    authDomain: "sigma-skibidi-b9e1e.firebaseapp.com",
    databaseURL: "https://sigma-skibidi-b9e1e-default-rtdb.firebaseio.com/",
    projectId: "sigma-skibidi-b9e1e",
    storageBucket: "sigma-skibidi-b9e1e.firebasestorage.app",
    messagingSenderId: "645635975542",
    appId: "1:645635975542:web:f22275c0e2b9ae00f8b257",
    measurementId: "G-G7DX318MFR"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Constants
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const ROWS = 6, COLS = 7;

  // State variables
  let board = [];
  let currentPlayer = PLAYER_RED;
  let myPlayer = PLAYER_NONE;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';
  let gameId = null;
  let currentUser = { id: null, username: null };
  let isInMatch = false;
  let gameState = 'idle'; // 'idle', 'waiting', 'playing', 'ended'

  // DOM elements
  const usernamePrompt = document.getElementById('usernamePrompt');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const menu = document.getElementById('menu');
  const modeSelect = document.getElementById('modeSelect');
  const aiDifficultyButtons = document.getElementById('aiDifficultyButtons');
  const createMatchBtn = document.getElementById('createMatchBtn');
  const leaveMatchBtn = document.getElementById('leaveMatchBtn');
  const refreshMatchesBtn = document.getElementById('refreshMatchesBtn');
  const statusDiv = document.getElementById('status');
  const matchListDiv = document.getElementById('matchList');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Initialize board
  function initBoard() {
    board = [];
    for (let r = 0; r < ROWS; r++) {
      const row = [];
      for (let c = 0; c < COLS; c++) {
        row.push(PLAYER_NONE);
      }
      board.push(row);
    }
  }

  // Draw the board and pieces
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cellSize = canvas.width / COLS;

    ctx.fillStyle = '#222244';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = c * cellSize;
        const y = r * cellSize;

        // Slots background
        ctx.beginPath();
        ctx.fillStyle = '#555577';
        ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 2 - 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();

        // Pieces
        if (board[r][c] !== PLAYER_NONE) {
          ctx.beginPath();
          ctx.fillStyle = board[r][c] === PLAYER_RED ? '#ff5555' : '#ffff77';
          ctx.shadowColor = 'rgba(0,0,0,0.5)';
          ctx.shadowBlur = 8;
          ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize / 2 - 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.closePath();
        }
      }
    }
  }

  // Place a piece in column for player
  function placePiece(col, player) {
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r][col] === PLAYER_NONE) {
        board[r][col] = player;
        return r;
      }
    }
    return -1;
  }

  // Check if player has won
  function checkWinner(player, b = board) {
    const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
    function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (b[r][c] !== player) continue;
        for (const [dr, dc] of directions) {
          let count = 1;
          for (let step = 1; step < 4; step++) {
            const nr = r + dr * step;
            const nc = c + dc * step;
            if (inBounds(nr, nc) && b[nr][nc] === player) count++;
            else break;
          }
          if (count >= 4) return true;
        }
      }
    }
    return false;
  }

  // Check if board full (draw)
  function isBoardFull(b = board) {
    for (let c = 0; c < COLS; c++) {
      if (b[0][c] === PLAYER_NONE) return false;
    }
    return true;
  }

  // Switch current player
  function switchPlayer() {
    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
  }

  // Update status message
  function updateStatus(text) {
    statusDiv.textContent = text || '';
  }

  // Reset game UI and state
  function resetGame() {
    initBoard();
    drawBoard();
    currentPlayer = PLAYER_RED;
    gameState = 'idle';
    gameId = null;
    myPlayer = PLAYER_NONE;
    isInMatch = false;
    leaveMatchBtn.disabled = true;
    canvas.style.display = 'none';
    updateStatus('');
  }

  // Create a new match (PvP or AI)
  function createMatch() {
    if (isInMatch) return alert("Already in a match!");
    initBoard();
    drawBoard();
    currentPlayer = PLAYER_RED;
    gameState = gameMode === 'pvp' ? 'waiting' : 'playing';
    isInMatch = true;
    leaveMatchBtn.disabled = false;
    myPlayer = PLAYER_RED;

    if (gameMode === 'pvp') {
      const newMatchRef = db.ref('matches').push();
      gameId = newMatchRef.key;
      const matchData = {
        owner: currentUser,
        opponent: null,
        board: board,
        currentPlayer: currentPlayer,
        mode: 'pvp',
        status: 'waiting',
        createdAt: Date.now(),
      };
      newMatchRef.set(matchData);

      updateStatus("Waiting for opponent to join...");
      listenToMatch(gameId);
      renderMatchList();
      canvas.style.display = 'block';
    } else if (gameMode === 'ai') {
      gameId = null;
      canvas.style.display = 'block';
      updateStatus("Your turn!");
    }
  }

  // Join an existing match (PvP)
  function joinMatch(id) {
    if (isInMatch) return alert("Already in a match!");
    const matchRef = db.ref('matches/' + id);
    matchRef.once('value', snapshot => {
      if (!snapshot.exists()) return alert("Match not found");
      const data = snapshot.val();
      if (data.status !== 'waiting') return alert("Match already started");
      if (data.owner.id === currentUser.id) return alert("Cannot join your own match");

      matchRef.update({
        opponent: currentUser,
        status: 'playing'
      });

      gameId = id;
      isInMatch = true;
      myPlayer = PLAYER_YELLOW;
      currentPlayer = data.currentPlayer;
      board = data.board || board;
      gameState = 'playing';

      updateStatus(`${data.owner.username} joined! Your turn!`);
      canvas.style.display = 'block';

      listenToMatch(gameId);
    });
  }

  // Leave current match
  function leaveMatch() {
    if (!isInMatch) return;
    if (gameMode === 'pvp' && gameId) {
      const matchRef = db.ref('matches/' + gameId);
      matchRef.once('value', snapshot => {
        if (!snapshot.exists()) return;

        const data = snapshot.val();

        if (data.owner.id === currentUser.id) {
          matchRef.remove();
        } else if (data.opponent && data.opponent.id === currentUser.id) {
          matchRef.update({
            opponent: null,
            status: 'waiting'
          });
        }
      });
    }
    resetGame();
    renderMatchList();
  }

  // Listen for match data updates
  function listenToMatch(id) {
    const matchRef = db.ref('matches/' + id);
    matchRef.on('value', snapshot => {
      if (!snapshot.exists()) {
        updateStatus('Match ended or deleted.');
        resetGame();
        renderMatchList();
        return;
      }
      const data = snapshot.val();
      board = data.board || board;
      currentPlayer = data.currentPlayer || PLAYER_RED;
      gameState = data.status === 'playing' ? 'playing' : data.status;
      drawBoard();

      if (gameState === 'waiting') {
        if (currentUser.id === data.owner.id) {
          updateStatus("Waiting for opponent to join...");
        } else {
          updateStatus(`${data.owner.username} joined! Your turn!`);
        }
      } else if (gameState === 'playing') {
        if (currentPlayer === myPlayer) {
          updateStatus("Your turn!");
        } else {
          updateStatus("Opponent's turn");
        }
      } else if (gameState === 'ended') {
        updateStatus("Game ended.");
        // Hide game UI on end
        canvas.style.display = 'none';
        leaveMatchBtn.disabled = true;
        isInMatch = false;
        myPlayer = PLAYER_NONE;
      }
      renderMatchList();
    });
  }

  // Update match board in database (PvP)
  function updateMatchBoard() {
    if (!gameId) return;
    const matchRef = db.ref('matches/' + gameId);
    matchRef.update({
      board: board,
      currentPlayer: currentPlayer
    });
  }

  // Handle clicks on canvas to place pieces
  function onCanvasClick(e) {
    if (!isInMatch || gameState !== 'playing') return;
    if (currentPlayer !== myPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const cellSize = canvas.width / COLS;
    const x = e.clientX - rect.left;
    const col = Math.floor(x / cellSize);

    if (col < 0 || col >= COLS) return;

    const row = placePiece(col, myPlayer);
    if (row === -1) return;

    drawBoard();

    if (checkWinner(myPlayer)) {
      gameState = 'ended';
      updateStatus("You win!");
      if (gameMode === 'pvp') {
        const matchRef = db.ref('matches/' + gameId);
        matchRef.update({ status: 'ended' });
      }
      canvas.style.display = 'none';
      leaveMatchBtn.disabled = true;
      isInMatch = false;
      myPlayer = PLAYER_NONE;
      renderMatchList();
      return;
    }
    if (isBoardFull()) {
      gameState = 'ended';
      updateStatus("Draw!");
      if (gameMode === 'pvp') {
        db.ref('matches/' + gameId).update({ status: 'ended' });
      }
      canvas.style.display = 'none';
      leaveMatchBtn.disabled = true;
      isInMatch = false;
      myPlayer = PLAYER_NONE;
      renderMatchList();
      return;
    }
    switchPlayer();
    updateStatus("Opponent's turn");
    if (gameMode === 'pvp') {
      updateMatchBoard();
    }
  }

  // Refresh matches list from database
  async function renderMatchList() {
    const snapshot = await db.ref('matches').once('value');
    const matches = snapshot.val() || {};
    matchListDiv.innerHTML = '';

    const keys = Object.keys(matches);
    if (keys.length === 0) {
      matchListDiv.textContent = "No available matches.";
      return;
    }

    keys.forEach(id => {
      const m = matches[id];
      if (m.status !== 'waiting') return;

      const div = document.createElement('div');
      div.classList.add('matchItem');

      const playersDiv = document.createElement('div');
      playersDiv.classList.add('matchPlayer');

      // Owner avatar circle with first letter
      const ownerAvatar = document.createElement('div');
      ownerAvatar.classList.add('avatar-circle');
      ownerAvatar.textContent = m.owner.username.charAt(0).toUpperCase();

      const ownerName = document.createElement('span');
      ownerName.textContent = m.owner.username;

      playersDiv.appendChild(ownerAvatar);
      playersDiv.appendChild(ownerName);

      const joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';
      joinBtn.onclick = () => joinMatch(id);

      div.appendChild(playersDiv);
      div.appendChild(joinBtn);
      matchListDiv.appendChild(div);
    });
  }

  // Handle AI difficulty button clicks
  function setAIDifficulty(level) {
    aiDifficulty = level;
    const buttons = aiDifficultyButtons.querySelectorAll('button');
    buttons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.level === level);
    });
  }

  // Show or hide AI difficulty options based on mode
  function updateModeUI() {
    gameMode = modeSelect.value;
    if (gameMode === 'ai') {
      aiDifficultyButtons.style.display = 'flex';
      createMatchBtn.textContent = "Start AI Game";
    } else {
      aiDifficultyButtons.style.display = 'none';
      createMatchBtn.textContent = "Create Match";
    }
  }

  // Validate username input for enabling start button
  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim().length === 0;
  });

  // Handle username submission
  usernameSubmit.addEventListener('click', () => {
    const uname = usernameInput.value.trim();
    if (!uname) return;
    currentUser = {
      id: 'user_' + Math.random().toString(36).slice(2, 10),
      username: uname
    };
    usernamePrompt.style.display = 'none';
    menu.style.display = 'flex';
    renderMatchList();
    updateModeUI();
  });

  // Handle mode selection changes
  modeSelect.addEventListener('change', updateModeUI);

  // AI difficulty buttons
  aiDifficultyButtons.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      setAIDifficulty(btn.dataset.level);
    });
  });

  // Create match / start AI game
  createMatchBtn.addEventListener('click', createMatch);

  // Leave match button
  leaveMatchBtn.addEventListener('click', leaveMatch);

  // Refresh matches list button
  refreshMatchesBtn.addEventListener('click', renderMatchList);

  // Canvas click to play move
  canvas.addEventListener('click', onCanvasClick);

  // Initialize board on page load
  initBoard();
  drawBoard();
  updateStatus("Please enter your username to start.");

})();
</script>

</body>
</html>
