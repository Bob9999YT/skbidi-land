<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }

  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }

  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
  }

  .user-profile img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }

  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }

  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 16px;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover {
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  button:disabled:hover {
    transform: none;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .matchItem .playerInfo img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
  }
  .matchItem button:hover {
    transform: scale(1.1);
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
  .no-matches {
    text-align: center;
    color: #888;
    padding: 20px;
  }
</style>
</head>
<body>
  <div class="header">
    <h1>Connect Four</h1>
    <div class="user-profile">
      <img id="userAvatar" src="https://via.placeholder.com/32" alt="User Avatar">
      <span id="username">Guest</span>
    </div>
  </div>

  <div class="menu">
    <label for="rows">Rows:</label>
    <select id="rows" name="rows"></select>

    <label for="cols">Columns:</label>
    <select id="cols" name="cols"></select>

    <label for="mode">Mode:</label>
    <select id="mode" name="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>

    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420"></canvas>
  <div id="status">Click "Create Game" to start playing!</div>

  <div id="matchList">
    <h3>Available Matches</h3>
    <div id="matchesContainer">No matches available.</div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');

  // Discord Activity setup
  let isDiscordActivity = false;
  let isConnected = false;
  let currentUser = {
    id: 'local_user',
    username: 'Guest',
    avatar: 'https://via.placeholder.com/32'
  };

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';
  let matches = {}; // id -> game object

  function initDiscord() {
    if (typeof DiscordSDK !== 'undefined') {
      isDiscordActivity = true;
      DiscordSDK.ready().then(() => {
        isConnected = true;
        DiscordSDK.commands.getUser().then(user => {
          currentUser = {
            id: user.id,
            username: user.username,
            avatar: user.avatar ? `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png` : 'https://via.placeholder.com/32'
          };
          updateUserProfile();
        });
      });
    }
  }

  function updateUserProfile() {
    document.getElementById('username').textContent = currentUser.username;
    document.getElementById('userAvatar').src = currentUser.avatar;
  }

  function broadcast(data) {
    if (isDiscordActivity && isConnected) {
      DiscordSDK.commands.sendActivityMessage(data);
    }
  }

  function toggleMatchList(show) {
    document.getElementById('matchList').style.display = show ? 'block' : 'none';
  }

  function setupUI() {
    initDiscord();
    updateUserProfile();

    for (let i = 4; i <= 10; i++) {
      rowSel.add(new Option(i, i));
      colSel.add(new Option(i, i));
    }
    rowSel.value = rows;
    colSel.value = cols;

    rowSel.addEventListener('change', () => {
      rows = parseInt(rowSel.value);
      updateCanvasSize();
    });
    colSel.addEventListener('change', () => {
      cols = parseInt(colSel.value);
      updateCanvasSize();
    });
    modeSel.addEventListener('change', () => {
      gameMode = modeSel.value;
      toggleAIDifficulty(gameMode === 'ai');
    });

    createBtn.addEventListener('click', onCreate);
    leaveBtn.addEventListener('click', onLeave);
    canvas.addEventListener('click', onClick);

    aiButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        aiButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.getAttribute('data-level');
        setStatus(`AI difficulty set to ${aiDifficulty}`);
      });
    });

    toggleAIDifficulty(false);
    toggleMatchList(true);
    updateUIButtons();
    renderMatchList();
    initBoard();
  }

  function toggleAIDifficulty(show) {
    aiDifficultyDiv.style.display = show ? 'flex' : 'none';
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    drawBoard();
  }

  function setStatus(text) {
    statusText.textContent = text;
  }

  function refreshMatches() {
    if (isDiscordActivity && isConnected) {
      broadcast({type: 'request_matches', userId: currentUser.id});
    }

    const now = Date.now();
    for (const id in matches) {
      if (now - matches[id].created > 300000) {
        delete matches[id];
      }
    }

    renderMatchList();
  }

  function addMatch(game) {
    game.created = Date.now();
    game.ownerInfo = currentUser;
    matches[game.id] = game;
    renderMatchList();
  }

  function updateUIButtons() {
    const isGameActive = ['playing', 'waiting', 'ended'].includes(gameState);
    leaveBtn.disabled = !isGameActive;
    createBtn.disabled = gameState === 'playing' || gameState === 'waiting';

    rowSel.disabled = isGameActive;
    colSel.disabled = isGameActive;
    modeSel.disabled = isGameActive;
  }

  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let color = "white";
        if (board[y][x] === PLAYER_RED) color = "#f44336";
        else if (board[y][x] === PLAYER_YELLOW) color = "#fdd835";

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(35 + x * 70, 35 + y * 70, 30, 0, 2 * Math.PI);
        ctx.fill();

        if (board[y][x] !== PLAYER_NONE) {
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }
  }

  function onCreate() {
    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;

    initBoard();
    gameId = 'game_' + Math.random().toString(36).substr(2, 8);

    currentGame = {
      id: gameId,
      rows,
      cols,
      mode: gameMode,
      difficulty: aiDifficulty,
      state: gameMode === 'ai' ? 'playing' : 'waiting',
      ownerId: currentUser.id,
      players: [currentUser.id],
    };

    myPlayer = PLAYER_RED;
    currentPlayer = PLAYER_RED;
    gameState = currentGame.state;

    if (gameMode === 'ai') {
      setStatus("Your turn! Click a column to drop your piece.");
      toggleMatchList(false);
    } else {
      setStatus("Waiting for opponent to join...");
      toggleMatchList(true);
      addMatch(currentGame);
    }

    updateUIButtons();
    broadcast({type: 'create', game: currentGame});
  }

  function onJoinGame(id) {
    if (!matches[id]) {
      setStatus("Match not found.");
      return;
    }
    currentGame = matches[id];
    rows = currentGame.rows;
    cols = currentGame.cols;
    gameId = currentGame.id;
    gameMode = currentGame.mode;
    aiDifficulty = currentGame.difficulty || 'normal';
    myPlayer = PLAYER_YELLOW;
    currentPlayer = PLAYER_RED;

    initBoard();

    gameState = 'playing';
    setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
    toggleMatchList(false);
    updateUIButtons();

    broadcast({type: 'join', gameId});
  }

  function onLeave() {
    if (!currentGame) return;

    broadcast({type: 'leave', gameId, ownerLeft: true});
    delete matches[gameId];
    resetGame();
    toggleMatchList(true);
    renderMatchList();
    setStatus("Game ended.");
  }

  function resetGame() {
    gameState = 'idle';
    currentGame = null;
    board = [];
    myPlayer = PLAYER_NONE;
    gameId = null;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    setStatus("Click \"Create Game\" to start playing!");
    updateUIButtons();
  }

  function isBoardFull() {
    return board.every(row => row.every(cell => cell !== PLAYER_NONE));
  }

  function checkWin() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x <= cols - 4; x++) {
        const val = board[y][x];
        if (val !== PLAYER_NONE &&
            val === board[y][x + 1] &&
            val === board[y][x + 2] &&
            val === board[y][x + 3]) {
          return val;
        }
      }
    }
    for (let x = 0; x < cols; x++) {
      for (let y = 0; y <= rows - 4; y++) {
        const val = board[y][x];
        if (val !== PLAYER_NONE &&
            val === board[y + 1][x] &&
            val === board[y + 2][x] &&
            val === board[y + 3][x]) {
          return val;
        }
      }
    }
    for (let y = 0; y <= rows - 4; y++) {
      for (let x = 0; x <= cols - 4; x++) {
        const val = board[y][x];
        if (val !== PLAYER_NONE &&
            val === board[y + 1][x + 1] &&
            val === board[y + 2][x + 2] &&
            val === board[y + 3][x + 3]) {
          return val;
        }
      }
    }
    for (let y = 3; y < rows; y++) {
      for (let x = 0; x <= cols - 4; x++) {
        const val = board[y][x];
        if (val !== PLAYER_NONE &&
            val === board[y - 1][x + 1] &&
            val === board[y - 2][x + 2] &&
            val === board[y - 3][x + 3]) {
          return val;
        }
      }
    }
    return PLAYER_NONE;
  }

  function dropPiece(col, player) {
    for (let row = rows - 1; row >= 0; row--) {
      if (board[row][col] === PLAYER_NONE) {
        board[row][col] = player;
        return row;
      }
    }
    return -1; // column full
  }

  function onClick(event) {
    if (gameState !== 'playing') return;
    if (currentPlayer !== myPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const col = Math.floor(x / 70);
    if (col < 0 || col >= cols) return;

    if (!canPlay(col)) {
      setStatus("Column is full!");
      return;
    }

    playTurn(col, myPlayer);
  }

  function canPlay(col) {
    return board[0][col] === PLAYER_NONE;
  }

  function playTurn(col, player) {
    const row = dropPiece(col, player);
    if (row === -1) return false;
    drawBoard();

    const winner = checkWin();
    if (winner !== PLAYER_NONE) {
      setStatus(winner === myPlayer ? "You win!" : "You lose!");
      gameState = 'ended';
      updateUIButtons();
      return true;
    }

    if (isBoardFull()) {
      setStatus("It's a draw!");
      gameState = 'ended';
      updateUIButtons();
      return true;
    }

    currentPlayer = player === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;

    if (gameMode === 'ai' && currentPlayer !== myPlayer && gameState === 'playing') {
      setStatus("AI's turn...");
      setTimeout(() => {
        aiMove();
      }, 800);
    } else {
      setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
    }

    return true;
  }

  function aiMove() {
    // Simple AI: pick random available column
    const availableCols = [];
    for (let c = 0; c < cols; c++) {
      if (canPlay(c)) availableCols.push(c);
    }
    if (availableCols.length === 0) return;

    const chosenCol = availableCols[Math.floor(Math.random() * availableCols.length)];
    playTurn(chosenCol, currentPlayer);
  }

function renderMatchList() {
  matchesContainer.innerHTML = '';
  const ids = Object.keys(matches);

  // Filter out your own matches
  const filteredIds = ids.filter(id => matches[id].ownerId !== currentUser.id);

  if (filteredIds.length === 0) {
    matchesContainer.innerHTML = '<div class="no-matches">No matches available.</div>';
    return;
  }

  filteredIds.forEach(id => {
    const match = matches[id];

    const div = document.createElement('div');
    div.className = 'matchItem';

    const playerInfo = document.createElement('div');
    playerInfo.className = 'playerInfo';

    const avatar = document.createElement('img');
    avatar.src = match.ownerInfo?.avatar || 'https://via.placeholder.com/28';
    avatar.alt = 'Owner Avatar';

    const name = document.createElement('span');
    name.textContent = match.ownerInfo?.username || 'Unknown';

    playerInfo.appendChild(avatar);
    playerInfo.appendChild(name);

    const btn = document.createElement('button');
    btn.textContent = 'Join';
    btn.addEventListener('click', () => {
      onJoinGame(id);
    });

    div.appendChild(playerInfo);
    div.appendChild(btn);

    matchesContainer.appendChild(div);
  });
}

  setupUI();
});
</script>
</body>
</html>
