<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin-bottom: 1rem;
    text-align: center;
  }
  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 16px;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover {
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .matchItem .playerInfo img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
  }
  .matchItem button:hover {
    transform: scale(1.1);
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
</style>
</head>
<body>
  <h1>Connect Four</h1>

  <div class="menu">
    <label for="rows">Rows:</label>
    <select id="rows" name="rows"></select>

    <label for="cols">Columns:</label>
    <select id="cols" name="cols"></select>

    <label for="mode">Mode:</label>
    <select id="mode" name="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>

    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420"></canvas>
  <div id="status">6 7 wheres the mangos</div>

  <div id="matchList">
    <h3>Available Matches</h3>
    <div id="matchesContainer">No matches available.</div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';
  let discordUser = null;
  let matches = {}; // id -> game object

  // Detect if running inside Discord embedded app for user info
  if (typeof DiscordSDK !== "undefined") {
    DiscordSDK.ready().then(() => {
      discordUser = DiscordSDK.getUser();
      renderMatchList();
    });
  }

  function setupUI() {
    for(let i=4; i<=10; i++) {
      rowSel.add(new Option(i, i));
      colSel.add(new Option(i, i));
    }
    rowSel.value = rows;
    colSel.value = cols;

    rowSel.onchange = () => { rows = +rowSel.value; updateCanvasSize(); };
    colSel.onchange = () => { cols = +colSel.value; updateCanvasSize(); };
    modeSel.onchange = () => {
      gameMode = modeSel.value;
      toggleAIDifficulty(gameMode === 'ai');
    };

    createBtn.onclick = onCreate;
    leaveBtn.onclick = onLeave;
    canvas.addEventListener('click', onClick);

    aiButtons.forEach(btn => {
      btn.onclick = () => {
        aiButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.getAttribute('data-level');
        setStatus(`AI difficulty set to ${aiDifficulty}`);
      };
    });

    toggleAIDifficulty(false);
    updateUIButtons();
    renderMatchList();
  }

  function toggleAIDifficulty(show) {
    aiDifficultyDiv.style.display = show ? 'flex' : 'none';
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    drawBoard();
  }

  function setStatus(text) {
    statusText.textContent = text;
  }

  function updateUIButtons() {
    leaveBtn.disabled = !(gameState === 'playing' || gameState === 'waiting' || gameState === 'ended');
    createBtn.disabled = (gameState === 'playing' || gameState === 'waiting');
  }

  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        ctx.fillStyle = board[y][x] === PLAYER_RED ? "#f44336" :
                        board[y][x] === PLAYER_YELLOW ? "#fdd835" : "white";
        ctx.beginPath();
        ctx.arc(35 + x*70, 35 + y*70, 30, 0, 2*Math.PI);
        ctx.fill();
      }
    }
  }

  function onCreate() {
    rows = +rowSel.value;
    cols = +colSel.value;
    gameMode = modeSel.value;

    initBoard();
    gameId = Math.random().toString(36).substr(2,8);

    currentGame = {
      id: gameId,
      rows,
      cols,
      mode: gameMode,
      difficulty: aiDifficulty,
      state: gameMode === 'ai' ? 'playing' : 'waiting',
      ownerId: discordUser ? discordUser.id : 'local', 
      players: [discordUser ? discordUser.id : 'local'],
    };

    myPlayer = PLAYER_RED;
    currentPlayer = PLAYER_RED;
    gameState = currentGame.state;

    if(gameMode === 'ai'){
      setStatus("Your turn!");
      toggleMatchList(false);
      updateUIButtons();
    } else {
      setStatus("Waiting for opponent...");
      toggleMatchList(true);
      addMatch(currentGame);
    }

    broadcast({ type: 'create', game: currentGame });
  }

  function onJoinGame(id) {
    if (!matches[id]) {
      setStatus("Match not found.");
      return;
    }
    currentGame = matches[id];
    rows = currentGame.rows;
    cols = currentGame.cols;
    gameId = currentGame.id;
    gameMode = currentGame.mode;
    aiDifficulty = currentGame.difficulty || 'normal';
    myPlayer = PLAYER_YELLOW;
    currentPlayer = PLAYER_RED;

    initBoard();

    gameState = 'playing';
    setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
    toggleMatchList(false);
    updateUIButtons();

    if(gameMode === 'ai' && currentPlayer !== myPlayer){
      setTimeout(aiMove, 500);
    }

    broadcast({ type: 'join', gameId });
  }

  function onLeave() {
    if(!currentGame) return;
    if(discordUser && currentGame.ownerId === discordUser.id){
      // Owner leaves: delete match
      broadcast({ type: 'leave', gameId, ownerLeft:true });
      delete matches[gameId];
      resetGame();
      toggleMatchList(true);
      renderMatchList();
      setStatus("Match deleted.");
    } else {
      // Player leaves: just leave match
      broadcast({ type: 'leave', gameId, ownerLeft:false, playerId: discordUser ? discordUser.id : 'local' });
      if(currentGame){
        const idx = currentGame.players.indexOf(discordUser ? discordUser.id : 'local');
        if(idx !== -1) currentGame.players.splice(idx,1);
      }
      resetGame();
      toggleMatchList(true);
      renderMatchList();
      setStatus("You left the match.");
    }
  }

  function resetGame() {
    gameState = 'idle';
    currentGame = null;
    board = [];
    myPlayer = PLAYER_NONE;
    gameId = null;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    setStatus("6 7 wheres the mangos");
    updateUIButtons();
  }

  function isBoardFull() {
    return board.every(row => row.every(cell => cell !== PLAYER_NONE));
  }

  // Basic win check (horizontal, vertical, diagonal)
  function checkWin() {
    // Horizontal check
    for(let y=0; y<rows; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y][x+1] && val === board[y][x+2] && val === board[y][x+3]){
          return true;
        }
      }
    }
    // Vertical check
    for(let x=0; x<cols; x++){
      for(let y=0; y<=rows-4; y++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y+1][x] && val === board[y+2][x] && val === board[y+3][x]){
          return true;
        }
      }
    }
    // Diagonal down-right
    for(let y=0; y<=rows-4; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y+1][x+1] && val === board[y+2][x+2] && val === board[y+3][x+3]){
          return true;
        }
      }
    }
    // Diagonal up-right
    for(let y=3; y<rows; y++){
      for(let x=0; x<=cols-4; x++){
        const val = board[y][x];
        if(val !== PLAYER_NONE && val === board[y-1][x+1] && val === board[y-2][x+2] && val === board[y-3][x+3]){
          return true;
        }
      }
    }
    return false;
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        ctx.fillStyle = board[y][x] === PLAYER_RED ? "#f44336" :
                        board[y][x] === PLAYER_YELLOW ? "#fdd835" : "white";
        ctx.beginPath();
        ctx.arc(35 + x*70, 35 + y*70, 30, 0, 2*Math.PI);
        ctx.fill();
      }
    }
  }

  function onClick(e) {
    if(gameState !== 'playing') return;
    if(myPlayer !== currentPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const xClick = e.clientX - rect.left;
    const col = Math.floor(xClick / 70);
    if(col < 0 || col >= cols) return;

    for(let y=rows-1; y>=0; y--){
      if(board[y][col] === PLAYER_NONE){
        board[y][col] = myPlayer;
        drawBoard();
        broadcast({type:'move', col, row:y, player: myPlayer, gameId});

        if(checkWin()){
          gameState = 'ended';
          setStatus("You win!");
          broadcast({type:'end', winner: myPlayer, gameId});
        } else if(isBoardFull()){
          gameState = 'ended';
          setStatus("Draw!");
          broadcast({type:'end', winner: PLAYER_NONE, gameId});
        } else {
          currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
          setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
          if(gameMode === 'ai' && currentPlayer !== myPlayer){
            setTimeout(aiMove, 500);
          }
        }
        break;
      }
    }
  }

  // AI logic: simple random moves, replace with difficulty levels if you want
  function aiMove() {
    if(gameState !== 'playing') return;
    if(currentPlayer !== PLAYER_YELLOW) return; // AI plays yellow

    // AI tries to place in a random available column
    let possibleCols = [];
    for(let c=0;c<cols;c++){
      if(board[0][c] === PLAYER_NONE){
        possibleCols.push(c);
      }
    }
    if(possibleCols.length === 0) return;

    // Simple AI: random choice
    let chosenCol = possibleCols[Math.floor(Math.random()*possibleCols.length)];
    for(let y=rows-1; y>=0; y--){
      if(board[y][chosenCol] === PLAYER_NONE){
        board[y][chosenCol] = PLAYER_YELLOW;
        drawBoard();
        broadcast({type:'move', col:chosenCol, row:y, player: PLAYER_YELLOW, gameId});

        if(checkWin()){
          gameState = 'ended';
          setStatus("AI wins!");
          broadcast({type:'end', winner: PLAYER_YELLOW, gameId});
        } else if(isBoardFull()){
          gameState = 'ended';
          setStatus("Draw!");
          broadcast({type:'end', winner: PLAYER_NONE, gameId});
        } else {
          currentPlayer = PLAYER_RED;
          setStatus("Your turn!");
        }
        break;
      }
    }
  }

  // Matches list UI rendering
  function renderMatchList() {
    matchesContainer.innerHTML = '';

    const userId = discordUser ? discordUser.id : 'local';

    let visibleMatches = Object.values(matches).filter(m => m.ownerId !== userId);

    if(visibleMatches.length === 0) {
      matchesContainer.textContent = "No matches available.";
      return;
    }

    for(let match of visibleMatches){
      const div = document.createElement('div');
      div.className = 'matchItem';

      const playerInfo = document.createElement('div');
      playerInfo.className = 'playerInfo';

      if(discordUser && match.ownerId) {
        // Show Discord user and avatar (fake for demo since we can't fetch others)
        let avatarUrl = `https://cdn.discordapp.com/avatars/${match.ownerId}/${match.ownerId}.png?size=64`;
        let img = document.createElement('img');
        img.src = avatarUrl;
        img.onerror = () => { img.src = 'https://cdn.discordapp.com/embed/avatars/0.png'; };
        playerInfo.appendChild(img);

        let span = document.createElement('span');
        span.textContent = `Owner: ${match.ownerId}`;
        playerInfo.appendChild(span);
      } else {
        playerInfo.textContent = `Owner: ${match.ownerId}`;
      }

      div.appendChild(playerInfo);

      let joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';
      joinBtn.onclick = () => {
        onJoinGame(match.id);
      };
      div.appendChild(joinBtn);

      matchesContainer.appendChild(div);
    }
  }

  function toggleMatchList(show) {
    document.getElementById('matchList').style.display = show ? 'block' : 'none';
  }

  // Broadcast simulation (replace with real socket or messaging service)
  // Here, we use localStorage events or custom event dispatching for demo

  function broadcast(msg) {
    // For demo purposes: dispatch event on window
    window.dispatchEvent(new CustomEvent('gameMessage', {detail: msg}));
  }

  window.addEventListener('gameMessage', e => {
    const msg = e.detail;
    if(msg.gameId && msg.gameId !== gameId) return; // Ignore messages not for our current game

    switch(msg.type) {
      case 'create':
        matches[msg.game.id] = msg.game;
        renderMatchList();
        break;
      case 'join':
        if(matches[msg.gameId]) {
          matches[msg.gameId].players.push(discordUser ? discordUser.id : 'local');
          matches[msg.gameId].state = 'playing';
          renderMatchList();
        }
        break;
      case 'leave':
        if(msg.ownerLeft){
          delete matches[msg.gameId];
          if(currentGame && currentGame.id === msg.gameId){
            resetGame();
            toggleMatchList(true);
          }
        } else {
          if(matches[msg.gameId]){
            const idx = matches[msg.gameId].players.indexOf(msg.playerId);
            if(idx !== -1) matches[msg.gameId].players.splice(idx,1);
          }
        }
        renderMatchList();
        break;
      case 'move':
        if(gameState !== 'playing') return;
        board[msg.row][msg.col] = msg.player;
        drawBoard();
        currentPlayer = msg.player === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
        setStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
        break;
      case 'end':
        gameState = 'ended';
        if(msg.winner === PLAYER_NONE){
          setStatus("Draw!");
        } else if(msg.winner === myPlayer){
          setStatus("You win!");
        } else {
          setStatus("You lose!");
        }
        updateUIButtons();
        break;
    }
  });

  setupUI();
  initBoard();
  setStatus("6 7 wheres the mangos");
  updateUIButtons();

});
</script>

</body>
</html>


