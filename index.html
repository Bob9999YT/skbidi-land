<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connect Four</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background-color: #1e1e2f;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 600px;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2rem;
      color: #ffaa00;
      margin: 0;
      text-align: center;
    }
    .user-profile {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #29293d;
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid #ffaa00;
      user-select: none;
    }
    .user-profile .avatar-circle {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #ffaa00;
      color: #111;
      font-weight: 700;
      font-size: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-transform: uppercase;
      overflow: hidden;
    }
    .user-profile .avatar-circle img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    .user-profile span {
      font-weight: 600;
      color: #ffaa00;
    }
    #usernamePromptContainer {
      max-width: 600px;
      width: 100%;
      background: #29293d;
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #ffaa00;
      margin-bottom: 20px;
    }
    #usernameInput, #avatarUrlInput {
      width: 100%;
      padding: 10px;
      margin: 6px 0;
      border-radius: 6px;
      border: 2px solid #ffaa00;
      background-color: #1f1f2b;
      color: white;
      font-size: 16px;
      box-sizing: border-box;
    }
    button {
      cursor: pointer;
      background-color: #ffaa00;
      border: none;
      color: #111;
      font-weight: 700;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    button:hover:not(:disabled) {
      background-color: #e6a100;
    }
    .menu {
      max-width: 600px;
      width: 100%;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    .menu label {
      color: #ffaa00;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 16px;
    }
    select {
      padding: 6px 8px;
      border-radius: 6px;
      border: 2px solid #ffaa00;
      background-color: #1f1f2b;
      color: white;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
    }
    #aiDifficultyButtons {
      display: flex;
      gap: 8px;
      max-width: 600px;
      margin-bottom: 20px;
      justify-content: center;
    }
    #aiDifficultyButtons button {
      background-color: #29293d;
      color: #ffaa00;
      border: 2px solid #ffaa00;
      font-weight: 600;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      transition: background-color 0.3s ease;
    }
    #aiDifficultyButtons button.active {
      background-color: #ffaa00;
      color: #111;
    }
    #gameCanvas {
      background-color: #ffaa00;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      max-width: 100%;
      height: auto;
    }
    #matchList {
      max-width: 600px;
      width: 100%;
      background: #29293d;
      padding: 10px;
      border-radius: 8px;
      border: 2px solid #ffaa00;
      margin-top: 10px;
      display: none;
    }
    #matchesContainer {
      max-height: 240px;
      overflow-y: auto;
      padding: 8px;
      background: #1f1f2b;
      border: 1.5px solid #ffaa00;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .matchItem {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #29293d;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #ffaa00;
    }
    .matchItem .playerInfo {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #ffaa00;
      font-weight: 600;
    }
    .matchItem .playerInfo .avatar-circle {
      width: 24px;
      height: 24px;
      font-size: 14px;
    }
    #turnIndicator {
      margin-top: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      color: #ffaa00;
      font-size: 18px;
    }
    #turnIndicator .avatar-circle {
      width: 24px;
      height: 24px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="usernamePromptContainer">
    <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
    <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" />
    <input id="avatarUrlInput" type="text" placeholder="Avatar Image/GIF URL (optional)"
           style="margin:10px 0; padding:8px; width:100%; background:#1f1f2b; color:white; border:2px solid #ffaa00; border-radius:6px;" />
    <button id="usernameSubmit" disabled>Start Playing</button>
  </div>

  <div class="header" style="display:none;">
    <h1>Connect Four</h1>
    <div class="user-profile">
      <div class="avatar-circle" id="userAvatar"></div>
      <span id="username">Guest</span>
    </div>
  </div>

  <div class="menu" style="display:none;">
    <label>Rows:
      <select id="rows"></select>
    </label>
    <label>Columns:
      <select id="cols"></select>
    </label>
    <label>Mode:
      <select id="mode">
        <option value="pvp">Player vs Player</option>
        <option value="ai">Player vs AI</option>
      </select>
    </label>
    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420"></canvas>

  <div id="turnIndicator" style="display:none;">
    <div class="avatar-circle" id="turnAvatar"></div>
    <span id="turnText"></span>
  </div>

  <div id="status" style="margin-top: 10px; text-align: center; font-weight: 700;"></div>

  <div id="matchList">
    <h3 style="color:#ffaa00; text-align:center;">Available Matches</h3>
    <button id="refreshMatchesBtn">Refresh Matches</button>
    <div id="matchesContainer">
      <div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>
    </div>
  </div>

  <script>
  (() => {
    const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
    let currentUser = { username: null, avatarUrl: null };
    let currentUserId = null;
    let rows = 6, cols = 7, board = [], currentPlayer = PLAYER_RED;
    let gameState = 'idle', myPlayer = PLAYER_NONE, gameId = null, gameMode = 'pvp', aiDifficulty = 'normal';
    let isInMatch = false;
    const STORAGE_KEY = 'connect_four_global_matches';
    const matches = {};

    const usernamePrompt = document.getElementById('usernamePromptContainer');
    const usernameInput = document.getElementById('usernameInput');
    const avatarUrlInput = document.getElementById('avatarUrlInput');
    const usernameSubmit = document.getElementById('usernameSubmit');
    const header = document.querySelector('.header');
    const userAvatarDiv = document.getElementById('userAvatar');
    const usernameSpan = document.getElementById('username');
    const menu = document.querySelector('.menu');
    const rowSel = document.getElementById('rows'), colSel = document.getElementById('cols'), modeSel = document.getElementById('mode');
    const createBtn = document.getElementById('create'), leaveBtn = document.getElementById('leave');
    const aiDiv = document.getElementById('aiDifficultyButtons'), aiBtns = aiDiv.querySelectorAll('button');
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status');
    const matchListDiv = document.getElementById('matchList'), matchesContainer = document.getElementById('matchesContainer');
    const refreshBtn = document.getElementById('refreshMatchesBtn');
    const turnIndicator = document.getElementById('turnIndicator');
    const turnAvatar = document.getElementById('turnAvatar');
    const turnText = document.getElementById('turnText');

    function getAvatarColor(name) {
      let hash = 0;
      for (let c of name) hash = c.charCodeAt(0) + ((hash << 5) - hash);
      const colors = ['#f44336','#e91e63','#9c27b0','#673ab7','#3f51b5','#2196f3','#03a9f4','#00bcd4','#009688','#4caf50','#8bc34a','#cddc39','#ffeb3b','#ffc107','#ff9800','#ff5722'];
      return colors[Math.abs(hash) % colors.length];
    }

    function createAvatarElement(username, avatarUrl, size = 24) {
      const div = document.createElement('div');
      div.className = 'avatar-circle';
      div.style.width = size + 'px';
      div.style.height = size + 'px';
      div.style.fontSize = (size * 0.58) + 'px';
      if (avatarUrl && avatarUrl.startsWith('http')) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = username;
        div.appendChild(img);
        div.style.backgroundColor = '';
      } else {
        div.textContent = username.charAt(0).toUpperCase();
        div.style.backgroundColor = getAvatarColor(username);
      }
      return div;
    }

    function updateUserProfile() {
      usernameSpan.textContent = currentUser.username;
      userAvatarDiv.innerHTML = '';
      if (currentUser.avatarUrl && currentUser.avatarUrl.startsWith('http')) {
        let img = document.createElement('img');
        img.src = currentUser.avatarUrl; img.alt = currentUser.username;
        userAvatarDiv.appendChild(img);
        userAvatarDiv.style.backgroundColor = '';
      } else {
        let letter = currentUser.username.charAt(0).toUpperCase();
        userAvatarDiv.textContent = letter;
        userAvatarDiv.style.backgroundColor = getAvatarColor(currentUser.username);
      }
    }

    function initBoard() {
      board = Array.from({ length: rows }, () => Array(cols).fill(PLAYER_NONE));
      updateCanvasSize();
    }
    function updateCanvasSize() {
      canvas.width = cols * 70; canvas.height = rows * 70;
      drawBoard();
    }
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffaa00'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
        let x = c * 70, y = r * 70;
        ctx.fillStyle = '#1e1e2f';
        ctx.beginPath(); ctx.arc(x + 35, y + 35, 30, 0, 2 * Math.PI); ctx.fill();
        if (board[r][c] === PLAYER_RED) {
          ctx.fillStyle = '#ff3333'; ctx.beginPath(); ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI); ctx.fill();
        } else if (board[r][c] === PLAYER_YELLOW) {
          ctx.fillStyle = '#ffff66'; ctx.beginPath(); ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI); ctx.fill();
        }
      }
    }

    function findLowestEmptyRow(col) {
      for (let r = rows - 1; r >= 0; r--) if (board[r][col] === PLAYER_NONE) return r;
      return -1;
    }
    function checkWin(player) {
      for (let r = 0; r < rows; r++) for (let c = 0; c <= cols - 4; c++)
        if ([0, 1, 2, 3].every(i => board[r][c + i] === player)) return true;
      for (let c = 0; c < cols; c++) for (let r = 0; r <= rows - 4; r++)
        if ([0, 1, 2, 3].every(i => board[r + i][c] === player)) return true;
      for (let r = 3; r < rows; r++) for (let c = 0; c <= cols - 4; c++)
        if ([0, 1, 2, 3].every(i => board[r - i][c + i] === player)) return true;
      for (let r = 0; r <= rows - 4; r++) for (let c = 0; c <= cols - 4; c++)
        if ([0, 1, 2, 3].every(i => board[r + i][c + i] === player)) return true;
      return false;
    }
    function checkDraw() {
      return board[0].every(cell => cell !== PLAYER_NONE);
    }

    function loadGlobalMatches() {
      let d = localStorage.getItem(STORAGE_KEY);
      if (!d) return {};
      try { return JSON.parse(d); } catch { return {}; }
    }
    function saveGlobalMatches() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
      window.dispatchEvent(new Event('storage'));
    }

    function refreshMatchesList() {
      matchesContainer.innerHTML = '';
      let any = false;
      Object.values(matches).forEach(m => {
        if (m.status !== 'waiting' || m.creatorId === currentUserId) return;
        any = true;
        let div = document.createElement('div'); div.className = 'matchItem';
        let infoDiv = document.createElement('div'); infoDiv.className = 'playerInfo';
        let avatar = createAvatarElement(m.creatorName, m.creatorAvatarUrl, 24);
        let nameSpan = document.createElement('span'); nameSpan.textContent = m.creatorName;
        infoDiv.append(avatar, nameSpan);
        let btn = document.createElement('button'); btn.textContent = 'Join'; btn.disabled = isInMatch; btn.onclick = () => joinMatch(m.id);
        div.append(infoDiv, btn);
        matchesContainer.appendChild(div);
      });
      if (!any) matchesContainer.innerHTML = '<div class="no-matches" style="text-align:center;color:#888;">No matches available.</div>';
    }

    function makeId() { return 'match_' + Math.random().toString(36).substr(2, 9); }

    function updateUIForMatch() {
      const inM = isInMatch;
      createBtn.disabled = inM; rowSel.disabled = inM;
      colSel.disabled = inM; modeSel.disabled = inM;
      leaveBtn.disabled = !inM;
      canvas.style.display = inM ? 'block' : 'none';
      turnIndicator.style.display = inM ? 'flex' : 'none';
      matchListDiv.style.display = (!inM && modeSel.value === 'pvp') ? 'block' : 'none';
      aiDiv.style.display = (modeSel.value === 'ai') && !inM ? 'flex' : 'none';
      statusText.textContent = '';
      if (!inM) {
        gameId = null; gameState = 'idle'; board = [];
        drawBoard();
      }
    }

    function updateTurnIndicator() {
      if (!isInMatch || gameState !== 'playing') {
        turnIndicator.style.display = 'none';
        return;
      }
      turnIndicator.style.display = 'flex';
      let playerId, playerName, playerAvatar;
      if (gameMode === 'pvp') {
        if (currentPlayer === PLAYER_RED) {
          playerId = matches[gameId]?.creatorId || null;
          playerName = matches[gameId]?.creatorName || "Red";
          playerAvatar = matches[gameId]?.creatorAvatarUrl || null;
        } else {
          playerId = matches[gameId]?.opponentId || null;
          playerName = matches[gameId]?.opponentName || "Yellow";
          playerAvatar = matches[gameId]?.opponentAvatarUrl || null;
        }
      } else {
        // AI turn
        playerId = currentUserId;
        playerName = currentUser.username;
        playerAvatar = currentUser.avatarUrl;
      }
      turnText.textContent = `${playerName}'s turn`;
      turnAvatar.innerHTML = '';
      if (playerAvatar && playerAvatar.startsWith('http')) {
        let img = document.createElement('img');
        img.src = playerAvatar; img.alt = playerName;
        turnAvatar.appendChild(img);
        turnAvatar.style.backgroundColor = '';
      } else {
        turnAvatar.textContent = playerName.charAt(0).toUpperCase();
        turnAvatar.style.backgroundColor = getAvatarColor(playerName);
      }
    }

    function createMatch() {
      if (isInMatch) return;
      rows = parseInt(rowSel.value);
      cols = parseInt(colSel.value);
      gameMode = modeSel.value;
      initBoard();
      currentPlayer = PLAYER_RED;
      gameState = 'waiting';
      myPlayer = PLAYER_RED;
      gameId = makeId();

      if (gameMode === 'pvp') {
        matches[gameId] = {
          id: gameId,
          creatorId: currentUserId,
          creatorName: currentUser.username,
          creatorAvatarUrl: currentUser.avatarUrl,
          opponentId: null,
          opponentName: null,
          opponentAvatarUrl: null,
          board: JSON.parse(JSON.stringify(board)),
          rows, cols,
          status: 'waiting',
          currentTurn: currentPlayer,
          mode: gameMode,
        };
        saveGlobalMatches();
        refreshMatchesList();
      } else if (gameMode === 'ai') {
        // AI mode - no match in global list, start immediately
        gameState = 'playing';
        myPlayer = PLAYER_RED;
        isInMatch = true;
        updateUIForMatch();
        updateTurnIndicator();
        statusText.textContent = "Your turn";
        return;
      }

      isInMatch = true;
      updateUIForMatch();
      updateTurnIndicator();
      statusText.textContent = "Waiting for opponent...";
    }

    function joinMatch(id) {
      if (isInMatch) return;
      let m = matches[id];
      if (!m || m.status !== 'waiting') return;
      rows = m.rows; cols = m.cols; gameMode = m.mode;
      initBoard();
      board = JSON.parse(JSON.stringify(m.board));
      myPlayer = PLAYER_YELLOW;
      currentPlayer = PLAYER_RED; // creator always starts
      gameState = 'playing';
      m.opponentId = currentUserId;
      m.opponentName = currentUser.username;
      m.opponentAvatarUrl = currentUser.avatarUrl;
      m.status = 'playing';
      m.currentTurn = currentPlayer;
      matches[id] = m;
      saveGlobalMatches();

      gameId = id;
      isInMatch = true;
      updateUIForMatch();
      updateTurnIndicator();
      statusText.textContent = `${m.creatorName}'s turn`;
      drawBoard();
      refreshMatchesList();
    }

    function leaveMatch() {
      if (!isInMatch) return;
      if (gameMode === 'pvp' && matches[gameId]) {
        delete matches[gameId];
        saveGlobalMatches();
      }
      gameId = null;
      myPlayer = PLAYER_NONE;
      gameState = 'idle';
      isInMatch = false;
      updateStatus('');
      updateUIForMatch();
      refreshMatchesList();
    }

    function updateStatus(text) {
      statusText.textContent = text;
    }

    function handleClick(evt) {
      if (!isInMatch || gameState !== 'playing' || myPlayer !== currentPlayer) return;
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const col = Math.floor(x / 70);
      if (col < 0 || col >= cols) return;
      const row = findLowestEmptyRow(col);
      if (row === -1) return;
      board[row][col] = currentPlayer;
      drawBoard();

      if (checkWin(currentPlayer)) {
        updateStatus(currentPlayer === myPlayer ? 'You win!' : 'You lose!');
        gameState = 'ended';
        if (gameMode === 'pvp' && matches[gameId]) {
          delete matches[gameId];
          saveGlobalMatches();
        }
        updateUIForMatch();
        return;
      }
      if (checkDraw()) {
        updateStatus('Draw!');
        gameState = 'ended';
        if (gameMode === 'pvp' && matches[gameId]) {
          delete matches[gameId];
          saveGlobalMatches();
        }
        updateUIForMatch();
        return;
      }

      currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;

      if (gameMode === 'pvp') {
        if (matches[gameId]) {
          matches[gameId].board = JSON.parse(JSON.stringify(board));
          matches[gameId].currentTurn = currentPlayer;
          saveGlobalMatches();
        }
        updateTurnIndicator();
        updateStatus(currentPlayer === myPlayer ? 'Your turn' : `${currentPlayer === PLAYER_RED ? matches[gameId].creatorName : matches[gameId].opponentName}'s turn`);
      } else if (gameMode === 'ai') {
        updateTurnIndicator();
        updateStatus("AI's turn");
        setTimeout(aiMove, 700);
      }
    }

    function aiMove() {
      if (gameState !== 'playing' || currentPlayer !== myPlayer) return;
      let validCols = [];
      for (let c = 0; c < cols; c++) if (findLowestEmptyRow(c) !== -1) validCols.push(c);
      if (validCols.length === 0) return;
      let col = validCols[Math.floor(Math.random() * validCols.length)];
      let row = findLowestEmptyRow(col);
      board[row][col] = currentPlayer;
      drawBoard();

      if (checkWin(currentPlayer)) {
        updateStatus('AI wins!');
        gameState = 'ended';
        updateUIForMatch();
        return;
      }
      if (checkDraw()) {
        updateStatus('Draw!');
        gameState = 'ended';
        updateUIForMatch();
        return;
      }

      currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
      updateTurnIndicator();
      updateStatus("Your turn");
    }

    function setupSelectOptions() {
      for (let i = 4; i <= 10; i++) {
        let optionR = document.createElement('option');
        optionR.value = i; optionR.textContent = i; 
        rowSel.appendChild(optionR);
        let optionC = document.createElement('option');
        optionC.value = i; optionC.textContent = i;
        colSel.appendChild(optionC);
      }
      rowSel.value = rows;
      colSel.value = cols;
    }

    function generateUserId() {
      return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    usernameInput.addEventListener('input', () => {
      usernameSubmit.disabled = usernameInput.value.trim().length < 2;
    });

    usernameSubmit.addEventListener('click', () => {
      const val = usernameInput.value.trim();
      if (!val) return;
      currentUser.username = val;
      currentUser.avatarUrl = avatarUrlInput.value.trim();
      currentUserId = generateUserId();
      updateUserProfile();
      usernamePrompt.style.display = 'none';
      header.style.display = 'flex';
      menu.style.display = 'flex';
      matchListDiv.style.display = 'block';
      setupSelectOptions();
      updateUIForMatch();
      refreshMatchesList();
    });

    createBtn.addEventListener('click', createMatch);
    leaveBtn.addEventListener('click', () => {
      leaveMatch();
    });

    canvas.addEventListener('click', handleClick);

    modeSel.addEventListener('change', () => {
      if (modeSel.value === 'ai') {
        aiDiv.style.display = 'flex';
        matchListDiv.style.display = 'none';
      } else {
        aiDiv.style.display = 'none';
        matchListDiv.style.display = isInMatch ? 'none' : 'block';
      }
      updateUIForMatch();
    });

    aiBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        aiBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.dataset.level;
      });
    });

    refreshBtn.addEventListener('click', () => {
      Object.assign(matches, loadGlobalMatches());
      if (!isInMatch) refreshMatchesList();
    });

    window.addEventListener('storage', (event) => {
      if (event.key === STORAGE_KEY) {
        Object.assign(matches, loadGlobalMatches());
        if (!isInMatch) refreshMatchesList();
        else if (gameMode === 'pvp' && matches[gameId]) {
          board = JSON.parse(JSON.stringify(matches[gameId].board));
          currentPlayer = matches[gameId].currentTurn;
          drawBoard();
          updateTurnIndicator();
          if (currentPlayer === myPlayer) updateStatus('Your turn');
          else updateStatus(`${currentPlayer === PLAYER_RED ? matches[gameId].creatorName : matches[gameId].opponentName}'s turn`);
        }
      }
    });

    setupSelectOptions();

  })();
  </script>
</body>
</html>
