<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }
  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
    user-select: none;
  }
  .user-profile .avatar-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ffaa00;
    color: #111;
    font-weight: 700;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-transform: uppercase;
    overflow: hidden;
  }
  .user-profile .avatar-circle img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }
  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }
  #matchList {
    max-width: 600px;
    width: 100%;
    margin-top: 10px;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
    padding: 8px;
    background: #1f1f2b;
    border: 1.5px solid #ffaa00;
    border-radius: 6px;
  }
  .matchItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 8px;
    border-bottom: 1px solid #444;
  }
  .matchItem:last-child {
    border-bottom: none;
  }
  .matchPlayer {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .matchPlayer .avatar-circle {
    width: 24px;
    height: 24px;
    font-size: 14px;
  }
  button {
    background-color: #ffaa00;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: 600;
    cursor: pointer;
  }
  button:disabled {
    background-color: #555;
    cursor: default;
  }
  #aiDifficultyButtons {
    margin-top: 10px;
    display: none;
    gap: 8px;
  }
  #aiDifficultyButtons button {
    padding: 4px 8px;
    font-weight: 600;
    border-radius: 4px;
    border: none;
    cursor: pointer;
  }
  #aiDifficultyButtons button.active {
    background-color: #ffaa00;
    color: black;
  }
  canvas {
    margin-top: 15px;
    background-color: #ffaa00;
    border-radius: 10px;
    cursor: pointer;
  }
  #status {
    margin-top: 15px;
    text-align: center;
    font-weight: 600;
    min-height: 30px;
  }
</style>
</head>
<body>

<!-- Username prompt -->
<div id="usernamePromptContainer" style="max-width: 400px; width: 100%;">
  <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
  <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <input id="avatarUrlInput" type="text" placeholder="Avatar Image/GIF URL (optional)"
         style="width: 100%; padding: 8px; margin-bottom: 15px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <button id="usernameSubmit" disabled style="width: 100%;">Start Playing</button>
</div>

<!-- Header -->
<div class="header" style="display:none;">
  <h1>Connect Four</h1>
  <div class="user-profile">
    <div class="avatar-circle" id="userAvatar"></div>
    <span id="usernameDisplay">Guest</span>
  </div>
</div>

<!-- Menu -->
<div class="menu" style="display:none; max-width: 600px; width: 100%; margin-top: 10px; gap: 12px; display: flex; flex-wrap: wrap; align-items: center;">
  <label style="color: #ffaa00; font-weight: 600;">Rows:
    <select id="rows"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Columns:
    <select id="cols"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Mode:
    <select id="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>
  </label>
  <button id="create">Create Game</button>
  <button id="leave" disabled>Leave Game</button>
</div>

<!-- AI difficulty -->
<div id="aiDifficultyButtons" style="max-width: 600px; width: 100%; justify-content: center;">
  <button data-level="easy">Easy</button>
  <button data-level="normal" class="active">Normal</button>
  <button data-level="hard">Hard</button>
  <button data-level="insane">Insane</button>
  <button data-level="impossible">Impossible</button>
</div>

<!-- Canvas -->
<canvas id="gameCanvas" width="490" height="420" style="display:none;"></canvas>

<!-- Status -->
<div id="status"></div>

<!-- Match List -->
<div id="matchList" style="max-width: 600px; width: 100%; margin-top: 10px;">
  <h3 style="color:#ffaa00; text-align:center;">Available Matches</h3>
  <button id="refreshMatchesBtn">Refresh Matches</button>
  <div id="matchesContainer">
    <div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>
  </div>
</div>

<script>
(() => {
  const PLAYER_NONE=0, PLAYER_RED=1, PLAYER_YELLOW=2;

  let currentUser = { username: null, avatarUrl: null, id: null };
  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';
  let isInMatch = false;

  const STORAGE_KEY = 'connect_four_global_matches';
  const matches = {};

  // DOM Elements
  const usernamePrompt = document.getElementById('usernamePromptContainer');
  const usernameInput = document.getElementById('usernameInput');
  const avatarUrlInput = document.getElementById('avatarUrlInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const header = document.querySelector('.header');
  const userAvatarDiv = document.getElementById('userAvatar');
  const usernameDisplay = document.getElementById('usernameDisplay');
  const menu = document.querySelector('.menu');
  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDiv = document.getElementById('aiDifficultyButtons');
  const aiBtns = aiDiv.querySelectorAll('button');
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchListDiv = document.getElementById('matchList');
  const matchesContainer = document.getElementById('matchesContainer');
  const refreshBtn = document.getElementById('refreshMatchesBtn');

  // Utilities
  function getAvatarColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const colors = ['#f44336','#e91e63','#9c27b0','#673ab7','#3f51b5','#2196f3','#03a9f4','#00bcd4','#009688','#4caf50','#8bc34a','#cddc39','#ffeb3b','#ffc107','#ff9800','#ff5722'];
    return colors[Math.abs(hash) % colors.length];
  }

  function createId() {
    return 'match_' + Math.random().toString(36).substr(2, 9);
  }

  function updateUserProfile() {
    usernameDisplay.textContent = currentUser.username;
    userAvatarDiv.innerHTML = '';
    if (currentUser.avatarUrl && currentUser.avatarUrl.startsWith('http')) {
      const img = document.createElement('img');
      img.src = currentUser.avatarUrl;
      img.alt = currentUser.username;
      userAvatarDiv.appendChild(img);
      userAvatarDiv.style.backgroundColor = 'transparent';
    } else {
      userAvatarDiv.textContent = currentUser.username.charAt(0).toUpperCase();
      userAvatarDiv.style.backgroundColor = getAvatarColor(currentUser.username);
    }
  }

  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    drawBoard();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = c * 70;
        const y = r * 70;
        ctx.fillStyle = '#1e1e2f';
        ctx.beginPath();
        ctx.arc(x + 35, y + 35, 30, 0, 2 * Math.PI);
        ctx.fill();

        if (board[r][c] === PLAYER_RED) {
          ctx.fillStyle = '#ff3333';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        } else if (board[r][c] === PLAYER_YELLOW) {
          ctx.fillStyle = '#ffff66';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
  }

  function findLowestEmptyRow(col) {
    for (let r = rows - 1; r >= 0; r--) {
      if (board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  function checkWin(player) {
    // horizontal
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0,1,2,3].every(i => board[r][c+i] === player)) return true;
      }
    }
    // vertical
    for (let c = 0; c < cols; c++) {
      for (let r = 0; r <= rows - 4; r++) {
        if ([0,1,2,3].every(i => board[r+i][c] === player)) return true;
      }
    }
    // diagonal down-right
    for (let r = 0; r <= rows - 4; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0,1,2,3].every(i => board[r+i][c+i] === player)) return true;
      }
    }
    // diagonal up-right
    for (let r = 3; r < rows; r++) {
      for (let c = 0; c <= cols - 4; c++) {
        if ([0,1,2,3].every(i => board[r-i][c+i] === player)) return true;
      }
    }
    return false;
  }

  function checkDraw() {
    return board[0].every(cell => cell !== PLAYER_NONE);
  }

  // Local storage matches helpers
  function loadGlobalMatches() {
    let d = localStorage.getItem(STORAGE_KEY);
    if (!d) return {};
    try {
      return JSON.parse(d);
    } catch {
      return {};
    }
  }

  function saveGlobalMatches() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
    window.dispatchEvent(new Event('storage'));
  }

  // Refresh and render match list
  function refreshMatchesList() {
    matchesContainer.innerHTML = '';
    let any = false;
    Object.values(matches).forEach(m => {
      if (m.mode !== 'pvp' || m.status !== 'waiting') return;
      if (isInMatch) {
        // Don't show matches if player is already in a match
        return;
      }
      if (m.creatorId === currentUser.id) return; // Don't show your own match
      any = true;

      const div = document.createElement('div');
      div.className = 'matchItem';

      // Small profile
      const playerDiv = document.createElement('div');
      playerDiv.className = 'matchPlayer';

      const avatar = document.createElement('div');
      avatar.className = 'avatar-circle';
      avatar.style.width = '24px';
      avatar.style.height = '24px';
      avatar.style.fontSize = '14px';
      if (m.creatorAvatarUrl && m.creatorAvatarUrl.startsWith('http')) {
        const img = document.createElement('img');
        img.src = m.creatorAvatarUrl;
        img.alt = m.creatorName;
        avatar.appendChild(img);
      } else {
        avatar.textContent = m.creatorName.charAt(0).toUpperCase();
        avatar.style.backgroundColor = getAvatarColor(m.creatorName);
      }

      const nameSpan = document.createElement('span');
      nameSpan.textContent = m.creatorName;

      playerDiv.appendChild(avatar);
      playerDiv.appendChild(nameSpan);

      const joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';
      joinBtn.disabled = isInMatch;
      joinBtn.onclick = () => joinMatch(m.id);

      div.appendChild(playerDiv);
      div.appendChild(joinBtn);

      matchesContainer.appendChild(div);
    });

    if (!any) {
      matchesContainer.innerHTML = '<div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>';
    }
  }

  // UI state updates
  function updateUIForMatch() {
    let inM = isInMatch;

    createBtn.disabled = inM;
    rowSel.disabled = inM;
    colSel.disabled = inM;
    modeSel.disabled = inM;
    leaveBtn.disabled = !inM;
    canvas.style.display = inM ? 'block' : 'none';
    statusText.style.display = inM ? 'block' : 'none';
    aiDiv.style.display = inM && gameMode === 'ai' ? 'flex' : 'none';
    matchListDiv.style.display = inM ? 'none' : 'block';
  }

  // Status helper
  function updateStatus(text, avatarUrl=null) {
    if (avatarUrl && avatarUrl.startsWith('http')) {
      statusText.innerHTML = `<span style="vertical-align: middle; display: inline-flex; align-items: center; gap: 6px;">
        <img src="${avatarUrl}" alt="avatar" style="width:24px; height:24px; border-radius:50%; object-fit:cover;"> ${text}
      </span>`;
    } else {
      statusText.textContent = text;
    }
  }

  // Create match
  function createMatch() {
    if (isInMatch) return;

    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;

    initBoard();

    currentPlayer = PLAYER_RED;
    myPlayer = PLAYER_RED;
    gameState = gameMode === 'pvp' ? 'waiting' : 'playing';

    if (gameMode === 'pvp') {
      gameId = createId();
      matches[gameId] = {
        id: gameId,
        creatorId: currentUser.id,
        creatorName: currentUser.username,
        creatorAvatarUrl: currentUser.avatarUrl,
        rows, cols, mode: gameMode,
        status: 'waiting',
        board,
        currentPlayer,
        players: { red: currentUser.id, yellow: null }
      };
      saveGlobalMatches();
    } else {
      // AI game - no global match created
      gameId = null;
      matchesContainer.style.display = 'none';
    }

    isInMatch = true;
    updateUIForMatch();

    if (gameMode === 'ai') {
      updateStatus(`${currentUser.username}'s turn`, currentUser.avatarUrl);
      canvas.style.display = 'block';
      drawBoard();
    } else {
      updateStatus('Waiting for opponent to join...');
      drawBoard();
    }
  }

  // Join a match
  function joinMatch(id) {
    if (isInMatch) return;

    const m = matches[id];
    if (!m || m.status !== 'waiting') return;

    rows = m.rows;
    cols = m.cols;
    board = m.board;
    gameMode = m.mode;

    initBoard();

    // Fill board with stored state (should be empty)
    board = JSON.parse(JSON.stringify(m.board));

    currentPlayer = m.currentPlayer;
    myPlayer = PLAYER_YELLOW;
    gameId = id;

    m.status = 'playing';
    m.players.yellow = currentUser.id;
    matches[id] = m;
    saveGlobalMatches();

    isInMatch = true;
    updateUIForMatch();
    drawBoard();
    updateStatus(`${m.creatorName}'s turn`, m.creatorAvatarUrl);
  }

  // Leave match
  function leaveMatch() {
    if (!isInMatch) return;

    if (gameMode === 'pvp' && gameId && matches[gameId]) {
      const m = matches[gameId];
      // Remove match if leaving
      if (m.creatorId === currentUser.id) {
        // Creator leaves - delete match
        delete matches[gameId];
      } else {
        // Other player leaves - reset match to waiting
        m.status = 'waiting';
        m.players.yellow = null;
        currentPlayer = PLAYER_RED;
        m.currentPlayer = currentPlayer;
        matches[gameId] = m;
      }
      saveGlobalMatches();
    }

    isInMatch = false;
    gameId = null;
    myPlayer = PLAYER_NONE;
    gameState = 'idle';
    statusText.textContent = '';
    canvas.style.display = 'none';
    updateUIForMatch();
    refreshMatchesList();
  }

  // Place piece
  function placePiece(col) {
    if (!isInMatch || gameState !== 'playing') return;
    if (myPlayer !== currentPlayer) return;

    const r = findLowestEmptyRow(col);
    if (r < 0) return;

    board[r][col] = currentPlayer;
    drawBoard();

    if (checkWin(currentPlayer)) {
      updateStatus(`🎉 ${currentUser.username} wins!`);
      gameState = 'ended';
      return;
    } else if (checkDraw()) {
      updateStatus(`Draw!`);
      gameState = 'ended';
      return;
    }

    // Switch turn
    currentPlayer = (currentPlayer === PLAYER_RED) ? PLAYER_YELLOW : PLAYER_RED;
    if (gameMode === 'pvp' && gameId && matches[gameId]) {
      matches[gameId].board = board;
      matches[gameId].currentPlayer = currentPlayer;
      saveGlobalMatches();
      const nextPlayerName = (currentPlayer === PLAYER_RED) ? matches[gameId].creatorName : 'Opponent';
      const nextPlayerAvatar = (currentPlayer === PLAYER_RED) ? matches[gameId].creatorAvatarUrl : null;
      updateStatus(`${matches[gameId].creatorName}'s turn`, matches[gameId].creatorAvatarUrl);
    } else if (gameMode === 'ai') {
      updateStatus(`${currentUser.username}'s turn`, currentUser.avatarUrl);
      // TODO: AI move
    }
  }

  // Initialize rows and cols selects
  function initSelects() {
    for (let i = 4; i <= 10; i++) {
      const rowOpt = document.createElement('option');
      rowOpt.value = i;
      rowOpt.textContent = i;
      if (i === 6) rowOpt.selected = true;
      rowSel.appendChild(rowOpt);

      const colOpt = document.createElement('option');
      colOpt.value = i;
      colOpt.textContent = i;
      if (i === 7) colOpt.selected = true;
      colSel.appendChild(colOpt);
    }
  }

  // Event listeners
  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim().length < 2;
  });

  usernameSubmit.addEventListener('click', () => {
    currentUser.username = usernameInput.value.trim();
    currentUser.avatarUrl = avatarUrlInput.value.trim() || null;
    currentUser.id = 'user_' + Math.random().toString(36).substr(2, 9);
    usernamePrompt.style.display = 'none';
    header.style.display = 'flex';
    menu.style.display = 'flex';
    matchListDiv.style.display = 'block';
    updateUserProfile();
    refreshMatchesList();
  });

  createBtn.addEventListener('click', createMatch);
  leaveBtn.addEventListener('click', leaveMatch);

  modeSel.addEventListener('change', () => {
    aiDiv.style.display = modeSel.value === 'ai' ? 'flex' : 'none';
  });

  aiBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      aiBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.dataset.level;
    });
  });

  canvas.addEventListener('click', e => {
    if (!isInMatch || gameState !== 'playing') return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const col = Math.floor(x / 70);
    placePiece(col);
  });

  refreshBtn.addEventListener('click', () => {
    Object.assign(matches, loadGlobalMatches());
    refreshMatchesList();
  });

  // Listen for storage events to sync matches across tabs
  window.addEventListener('storage', e => {
    if (e.key === STORAGE_KEY) {
      Object.assign(matches, loadGlobalMatches());
      if (!isInMatch) refreshMatchesList();
    }
  });

  // Init UI
  initSelects();
  updateUIForMatch();
  drawBoard();

})();
</script>

</body>
</html>
