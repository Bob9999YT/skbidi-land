<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }
  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
    user-select: none;
  }
  .user-profile .avatar-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ffaa00;
    color: #111;
    font-weight: 700;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-transform: uppercase;
    overflow: hidden;
  }
  .user-profile .avatar-circle img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }
  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }
  #matchList {
    max-width: 600px;
    width: 100%;
    margin-top: 10px;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
    padding: 8px;
    background: #1f1f2b;
    border: 1.5px solid #ffaa00;
    border-radius: 6px;
  }
  .matchItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 8px;
    border-bottom: 1px solid #444;
  }
  .matchItem:last-child {
    border-bottom: none;
  }
  .matchPlayer {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .matchPlayer .avatar-circle {
    width: 24px;
    height: 24px;
    font-size: 14px;
    flex-shrink: 0;
  }
  button {
    background-color: #ffaa00;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: 600;
    cursor: pointer;
  }
  button:disabled {
    background-color: #555;
    cursor: default;
  }
  #aiDifficultyButtons {
    margin-top: 10px;
    display: none;
    gap: 8px;
  }
  #aiDifficultyButtons button {
    padding: 4px 8px;
    font-weight: 600;
    border-radius: 4px;
    border: none;
    cursor: pointer;
  }
  #aiDifficultyButtons button.active {
    background-color: #ffaa00;
    color: black;
  }
  canvas {
    margin-top: 15px;
    background-color: #ffaa00;
    border-radius: 10px;
    cursor: pointer;
  }
  #status {
    margin-top: 15px;
    text-align: center;
    font-weight: 600;
    min-height: 30px;
  }
  /* Hide everything except username prompt initially */
  .hide {
    display: none !important;
  }
</style>
</head>
<body>

<!-- Username prompt -->
<div id="usernamePromptContainer" style="max-width: 400px; width: 100%;">
  <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
  <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <input id="avatarUrlInput" type="text" placeholder="Avatar Image/GIF URL (optional)"
         style="width: 100%; padding: 8px; margin-bottom: 15px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <button id="usernameSubmit" disabled style="width: 100%;">Start Playing</button>
</div>

<!-- Header -->
<div class="header hide">
  <h1>Connect Four</h1>
  <div class="user-profile">
    <div class="avatar-circle" id="userAvatar"></div>
    <span id="usernameDisplay">Guest</span>
  </div>
</div>

<!-- Menu -->
<div class="menu hide" style="max-width: 600px; width: 100%; margin-top: 10px; gap: 12px; display: flex; flex-wrap: wrap; align-items: center;">
  <label style="color: #ffaa00; font-weight: 600;">Rows:
    <select id="rows"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Columns:
    <select id="cols"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Mode:
    <select id="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>
  </label>
  <button id="create">Create Game</button>
  <button id="leave" disabled>Leave Game</button>
</div>

<!-- AI difficulty -->
<div id="aiDifficultyButtons" class="hide" style="max-width: 600px; width: 100%; justify-content: center; gap: 8px;">
  <button data-level="easy">Easy</button>
  <button data-level="normal" class="active">Normal</button>
  <button data-level="hard">Hard</button>
  <button data-level="insane">Insane</button>
  <button data-level="impossible">Impossible</button>
</div>

<!-- Canvas -->
<canvas id="gameCanvas" width="490" height="420" class="hide"></canvas>

<!-- Status -->
<div id="status" class="hide"></div>

<!-- Match List -->
<div id="matchList" class="hide" style="max-width: 600px; width: 100%; margin-top: 10px;">
  <h3 style="color:#ffaa00; text-align:center;">Available Matches</h3>
  <button id="refreshMatchesBtn">Refresh Matches</button>
  <div id="matchesContainer">
    <div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>
  </div>
</div>

<script>
(() => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;

  let currentUser = { username: null, avatarUrl: null, id: null };
  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';
  let isInMatch = false;

  const STORAGE_KEY = 'connect_four_global_matches';
  const matches = {};

  // DOM Elements
  const usernamePrompt = document.getElementById('usernamePromptContainer');
  const usernameInput = document.getElementById('usernameInput');
  const avatarUrlInput = document.getElementById('avatarUrlInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const header = document.querySelector('.header');
  const userAvatarDiv = document.getElementById('userAvatar');
  const usernameDisplay = document.getElementById('usernameDisplay');
  const menu = document.querySelector('.menu');
  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDiv = document.getElementById('aiDifficultyButtons');
  const aiBtns = aiDiv.querySelectorAll('button');
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchListDiv = document.getElementById('matchList');
  const matchesContainer = document.getElementById('matchesContainer');
  const refreshBtn = document.getElementById('refreshMatchesBtn');

  // Utilities
  function getAvatarColor(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const colors = ['#f44336','#e91e63','#9c27b0','#673ab7','#3f51b5','#2196f3','#03a9f4','#00bcd4','#009688','#4caf50','#8bc34a','#cddc39','#ffeb3b','#ffc107','#ff9800','#ff5722'];
    return colors[Math.abs(hash) % colors.length];
  }

  function createId() {
    return 'match_' + Math.random().toString(36).substr(2, 9);
  }

  function updateUserProfile() {
    usernameDisplay.textContent = currentUser.username;
    userAvatarDiv.innerHTML = '';
    if (currentUser.avatarUrl && currentUser.avatarUrl.startsWith('http')) {
      const img = document.createElement('img');
      img.src = currentUser.avatarUrl;
      img.alt = currentUser.username;
      userAvatarDiv.appendChild(img);
      userAvatarDiv.style.backgroundColor = 'transparent';
    } else {
      userAvatarDiv.textContent = currentUser.username.charAt(0).toUpperCase();
      userAvatarDiv.style.backgroundColor = getAvatarColor(currentUser.username);
    }
  }

  // Board setup
  function initBoard() {
    board = [];
    for(let r=0; r<rows; r++){
      const row = [];
      for(let c=0; c<cols; c++){
        row.push(PLAYER_NONE);
      }
      board.push(row);
    }
  }

  // Draw board
  function drawBoard() {
    const cellSize = 70;
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Background slots
    ctx.fillStyle = '#222244';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw slots
    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        const x = c * cellSize;
        const y = r * cellSize;
        ctx.beginPath();
        ctx.fillStyle = '#555577';
        ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2 - 6, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();

        if(board[r][c] !== PLAYER_NONE){
          ctx.beginPath();
          ctx.fillStyle = board[r][c] === PLAYER_RED ? '#ff5555' : '#ffff77';
          ctx.shadowColor = 'rgba(0,0,0,0.5)';
          ctx.shadowBlur = 8;
          ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2 - 12, 0, Math.PI*2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.closePath();
        }
      }
    }
  }

  // Check for winner (horizontal, vertical, diagonal)
  function checkWinner(player) {
    function inBounds(r,c) {
      return r >= 0 && r < rows && c >= 0 && c < cols;
    }
    const directions = [[0,1],[1,0],[1,1],[1,-1]];
    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        if(board[r][c] !== player) continue;
        for(const [dr,dc] of directions){
          let count = 1;
          for(let step=1; step<4; step++){
            const nr = r + dr*step;
            const nc = c + dc*step;
            if(inBounds(nr,nc) && board[nr][nc] === player) count++;
            else break;
          }
          if(count >=4) return true;
        }
      }
    }
    return false;
  }

  // Check if board full
  function isBoardFull() {
    for(let c=0; c<cols; c++){
      if(board[0][c] === PLAYER_NONE) return false;
    }
    return true;
  }

  // Place piece in column, returns row or -1 if full
  function placePiece(col, player) {
    for(let r=rows-1; r>=0; r--){
      if(board[r][col] === PLAYER_NONE){
        board[r][col] = player;
        return r;
      }
    }
    return -1;
  }

  // Switch current player
  function switchPlayer() {
    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
  }

  // Update status text
  function updateStatus(text) {
    if(text) statusText.textContent = text;
    else {
      if(gameState === 'playing'){
        statusText.textContent = (myPlayer === currentPlayer) ? "Your turn!" : "Opponent's turn";
      } else if(gameState === 'waiting'){
        statusText.textContent = 'Waiting for opponent to join...';
      } else if(gameState === 'ended'){
        statusText.textContent = 'Game over.';
      } else {
        statusText.textContent = '';
      }
    }
  }

  // Save matches to localStorage
  function saveMatches() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
    } catch(e) {
      console.warn("Could not save matches:", e);
    }
  }

  // Load matches from localStorage
  function loadMatches() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if(stored){
        const obj = JSON.parse(stored);
        for(const key in obj){
          matches[key] = obj[key];
        }
      }
    } catch(e){
      console.warn("Could not load matches:", e);
    }
  }

  // Render match list for PvP mode
  function renderMatchList() {
    matchesContainer.innerHTML = '';
    const availableMatches = Object.values(matches).filter(m => m.mode === 'pvp' && (m.status === 'waiting' || m.status === 'playing'));
    if(availableMatches.length === 0){
      const noMatchesDiv = document.createElement('div');
      noMatchesDiv.classList.add('no-matches');
      noMatchesDiv.style.textAlign = 'center';
      noMatchesDiv.style.color = '#888';
      noMatchesDiv.textContent = 'No matches available.';
      matchesContainer.appendChild(noMatchesDiv);
      return;
    }

    availableMatches.forEach(m => {
      const div = document.createElement('div');
      div.classList.add('matchItem');

      // Owner info
      const ownerDiv = document.createElement('div');
      ownerDiv.classList.add('matchPlayer');
      const ownerAvatar = document.createElement('div');
      ownerAvatar.classList.add('avatar-circle');
      if(m.owner.avatarUrl && m.owner.avatarUrl.startsWith('http')){
        const img = document.createElement('img');
        img.src = m.owner.avatarUrl;
        img.alt = m.owner.username;
        ownerAvatar.appendChild(img);
      } else {
        ownerAvatar.textContent = m.owner.username.charAt(0).toUpperCase();
        ownerAvatar.style.backgroundColor = getAvatarColor(m.owner.username);
      }
      ownerDiv.appendChild(ownerAvatar);
      const ownerNameSpan = document.createElement('span');
      ownerNameSpan.textContent = m.owner.username;
      ownerNameSpan.style.color = '#ffaa00';
      ownerDiv.appendChild(ownerNameSpan);

      div.appendChild(ownerDiv);

      // Status / Action
      const actionDiv = document.createElement('div');
      if(m.status === 'waiting'){
        const joinBtn = document.createElement('button');
        joinBtn.textContent = 'Join';
        joinBtn.onclick = () => joinMatch(m.id);
        actionDiv.appendChild(joinBtn);
      } else if(m.status === 'playing'){
        actionDiv.textContent = 'In Progress';
        actionDiv.style.color = '#aaa';
      } else {
        actionDiv.textContent = 'Unknown';
      }

      div.appendChild(actionDiv);
      matchesContainer.appendChild(div);
    });
  }

  // Join a PvP match
  function joinMatch(id) {
    if(isInMatch) return alert('You are already in a match.');
    const m = matches[id];
    if(!m) return alert('Match no longer available.');
    if(m.status !== 'waiting') return alert('Match already started.');

    m.opponent = { ...currentUser };
    m.status = 'playing';
    isInMatch = true;
    gameId = id;
    gameState = 'playing';
    myPlayer = PLAYER_YELLOW;
    currentPlayer = PLAYER_RED;
    board = JSON.parse(JSON.stringify(m.board));

    saveMatches();
    renderMatchList();
    updateStatus(`${m.opponent.username} joined! Your turn!`);

    drawBoard();
    canvas.classList.remove('hide');
    matchListDiv.classList.add('hide');
    leaveBtn.disabled = false;
  }

  // Create a match (PvP or AI)
  function createMatch() {
    if(isInMatch) return;

    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);

    initBoard();
    drawBoard();
    gameId = createId();
    currentPlayer = PLAYER_RED;
    gameState = 'playing';
    leaveBtn.disabled = false;
    isInMatch = true;

    if(gameMode === 'pvp'){
      matches[gameId] = {
        id: gameId,
        owner: { ...currentUser },
        opponent: null,
        board: JSON.parse(JSON.stringify(board)),
        currentPlayer: PLAYER_RED,
        mode: 'pvp',
        status: 'waiting',
      };
      saveMatches();
      renderMatchList();
      matchListDiv.classList.remove('hide');
      canvas.classList.remove('hide');
      updateStatus('Waiting for opponent to join...');
    } else if(gameMode === 'ai'){
      aiDifficulty = aiDiv.querySelector('button.active').dataset.level || 'normal';
      myPlayer = PLAYER_RED;
      canvas.classList.remove('hide');
      matchListDiv.classList.add('hide');
      updateStatus('Your turn!');
    }
  }

  // Leave current match
  function leaveMatch() {
    if(!isInMatch) return;
    if(gameMode === 'pvp' && gameId && matches[gameId]){
      if(matches[gameId].owner.id === currentUser.id){
        // Owner leaving: delete match
        delete matches[gameId];
      } else if(matches[gameId].opponent && matches[gameId].opponent.id === currentUser.id){
        // Opponent leaving: revert match to waiting
        matches[gameId].opponent = null;
        matches[gameId].status = 'waiting';
      }
      saveMatches();
      renderMatchList();
      matchListDiv.classList.remove('hide');
    }
    isInMatch = false;
    gameId = null;
    gameState = 'idle';
    myPlayer = PLAYER_NONE;
    leaveBtn.disabled = true;
    canvas.classList.add('hide');
    updateStatus('');
  }

  // Make AI move (simple heuristics - can improve difficulty later)
  function aiMove() {
    if(gameMode !== 'ai' || gameState !== 'playing' || currentPlayer !== PLAYER_YELLOW) return;

    // Choose AI difficulty logic
    let col;
    switch(aiDifficulty){
      case 'easy': col = easyAI(); break;
      case 'normal': col = normalAI(); break;
      case 'hard': col = hardAI(); break;
      case 'insane': col = insaneAI(); break;
      case 'impossible': col = impossibleAI(); break;
      default: col = normalAI();
    }

    if(col === -1){
      // No valid moves? Just skip turn
      switchPlayer();
      updateStatus("Your turn!");
      return;
    }

    placePiece(col, PLAYER_YELLOW);
    drawBoard();

    if(checkWinner(PLAYER_YELLOW)){
      gameState = 'ended';
      updateStatus('AI wins!');
      isInMatch = false;
      leaveBtn.disabled = true;
      return;
    }
    if(isBoardFull()){
      gameState = 'ended';
      updateStatus('Draw!');
      isInMatch = false;
      leaveBtn.disabled = true;
      return;
    }
    switchPlayer();
    updateStatus('Your turn!');
  }

  // Basic AI helpers
  function easyAI() {
    // Random valid column
    const validCols = [];
    for(let c=0; c<cols; c++){
      if(board[0][c] === PLAYER_NONE) validCols.push(c);
    }
    if(validCols.length === 0) return -1;
    return validCols[Math.floor(Math.random()*validCols.length)];
  }

  function normalAI() {
    // Try to win or block opponent else random
    for(let c=0; c<cols; c++){
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_YELLOW;
      if(checkWinner(PLAYER_YELLOW)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    for(let c=0; c<cols; c++){
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_RED;
      if(checkWinner(PLAYER_RED)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    return easyAI();
  }

  function hardAI() {
    // Normal AI + prefer center columns
    const center = Math.floor(cols/2);
    const order = [];
    for(let offset=0; offset <= center; offset++){
      if(center - offset >= 0) order.push(center - offset);
      if(center + offset < cols) order.push(center + offset);
    }
    for(let c of order){
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_YELLOW;
      if(checkWinner(PLAYER_YELLOW)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    for(let c of order){
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_RED;
      if(checkWinner(PLAYER_RED)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    return easyAI();
  }

  function insaneAI() {
    // Hard AI + look ahead 1 move (simple minimax depth 1)
    const validCols = [];
    for(let c=0; c<cols; c++){
      if(board[0][c] === PLAYER_NONE) validCols.push(c);
    }
    if(validCols.length === 0) return -1;

    let bestCol = validCols[0];
    let bestScore = -Infinity;
    for(let c of validCols){
      let r = getAvailableRow(c);
      board[r][c] = PLAYER_YELLOW;
      let score = minimax(false, 1);
      board[r][c] = PLAYER_NONE;
      if(score > bestScore){
        bestScore = score;
        bestCol = c;
      }
    }
    return bestCol;
  }

  function impossibleAI() {
    // Minimax depth 4 (very slow but strong)
    const validCols = [];
    for(let c=0; c<cols; c++){
      if(board[0][c] === PLAYER_NONE) validCols.push(c);
    }
    if(validCols.length === 0) return -1;

    let bestCol = validCols[0];
    let bestScore = -Infinity;
    for(let c of validCols){
      let r = getAvailableRow(c);
      board[r][c] = PLAYER_YELLOW;
      let score = minimax(false, 4);
      board[r][c] = PLAYER_NONE;
      if(score > bestScore){
        bestScore = score;
        bestCol = c;
      }
    }
    return bestCol;
  }

  function minimax(isMaximizing, depth) {
    if(checkWinner(PLAYER_YELLOW)) return 1000;
    if(checkWinner(PLAYER_RED)) return -1000;
    if(isBoardFull() || depth === 0) return 0;

    const validCols = [];
    for(let c=0; c<cols; c++){
      if(board[0][c] === PLAYER_NONE) validCols.push(c);
    }
    if(isMaximizing){
      let maxEval = -Infinity;
      for(let c of validCols){
        let r = getAvailableRow(c);
        board[r][c] = PLAYER_YELLOW;
        let evalScore = minimax(false, depth-1);
        board[r][c] = PLAYER_NONE;
        maxEval = Math.max(maxEval, evalScore);
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for(let c of validCols){
        let r = getAvailableRow(c);
        board[r][c] = PLAYER_RED;
        let evalScore = minimax(true, depth-1);
        board[r][c] = PLAYER_NONE;
        minEval = Math.min(minEval, evalScore);
      }
      return minEval;
    }
  }

  // Get next available row for a column
  function getAvailableRow(col) {
    for(let r=rows-1; r>=0; r--){
      if(board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  // Handle canvas click (place piece)
  function onCanvasClick(e) {
    if(!isInMatch || gameState !== 'playing') return;
    if(myPlayer !== currentPlayer) return;

    const rect = canvas.getBoundingClientRect();
    const cellSize = canvas.width / cols;
    const x = e.clientX - rect.left;
    const col = Math.floor(x / cellSize);

    if(col < 0 || col >= cols) return;

    const row = placePiece(col, myPlayer);
    if(row === -1) return; // full column

    drawBoard();

    if(checkWinner(myPlayer)){
      gameState = 'ended';
      updateStatus('You win!');
      isInMatch = false;
      leaveBtn.disabled = true;
      if(gameMode === 'pvp') updateMatchBoard();
      return;
    }
    if(isBoardFull()){
      gameState = 'ended';
      updateStatus('Draw!');
      isInMatch = false;
      leaveBtn.disabled = true;
      if(gameMode === 'pvp') updateMatchBoard();
      return;
    }

    switchPlayer();

    if(gameMode === 'pvp'){
      updateMatchBoard();
      updateStatus("Opponent's turn");
    } else if(gameMode === 'ai'){
      updateStatus("AI's turn");
      setTimeout(() => {
        aiMove();
      }, 800);
    }
  }

  // Update match board in storage for PvP
  function updateMatchBoard() {
    if(gameMode !== 'pvp' || !gameId) return;
    const m = matches[gameId];
    if(!m) return;
    m.board = JSON.parse(JSON.stringify(board));
    m.currentPlayer = currentPlayer;
    saveMatches();
  }

  // Handle AI difficulty buttons click
  aiBtns.forEach(btn => {
    btn.onclick = () => {
      aiBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.dataset.level;
    };
  });

  // Setup rows and cols selectors
  function populateSizeSelectors() {
    for(let i=4; i<=10; i++){
      const optR = document.createElement('option');
      optR.value = i;
      optR.textContent = i;
      if(i === 6) optR.selected = true;
      rowSel.appendChild(optR);

      const optC = document.createElement('option');
      optC.value = i;
      optC.textContent = i;
      if(i === 7) optC.selected = true;
      colSel.appendChild(optC);
    }
  }

  // Handle mode change: show/hide AI difficulty and match list
  function onModeChange() {
    gameMode = modeSel.value;
    if(gameMode === 'ai'){
      aiDiv.style.display = 'flex';
      matchListDiv.classList.add('hide');
    } else {
      aiDiv.style.display = 'none';
      matchListDiv.classList.remove('hide');
    }
  }

  // Periodically refresh match list from storage
  function periodicRefresh() {
    loadMatches();
    if(gameMode === 'pvp' && !isInMatch){
      renderMatchList();
    }
  }

  // Username submit
  usernameInput.oninput = () => {
    usernameSubmit.disabled = usernameInput.value.trim().length === 0;
  };
  usernameSubmit.onclick = () => {
    const name = usernameInput.value.trim();
    if(!name) return;
    currentUser.username = name;
    currentUser.avatarUrl = avatarUrlInput.value.trim();
    currentUser.id = 'user_' + Math.random().toString(36).substr(2,9);

    usernamePrompt.classList.add('hide');
    header.classList.remove('hide');
    menu.classList.remove('hide');
    matchListDiv.classList.remove('hide');

    updateUserProfile();
    populateSizeSelectors();
    onModeChange();
    renderMatchList();
  };

  createBtn.onclick = () => {
    createMatch();
  };
  leaveBtn.onclick = () => {
    leaveMatch();
  };

  modeSel.onchange = () => {
    onModeChange();
  };

  refreshBtn.onclick = () => {
    loadMatches();
    renderMatchList();
  };

  canvas.onclick = onCanvasClick;

  // Auto refresh matches every 5 seconds
  setInterval(periodicRefresh, 5000);

  // Initial setup
  updateStatus('');
})();
</script>
</body>
</html>
