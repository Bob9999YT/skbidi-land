<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  /* Your existing CSS here, unchanged */
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }

  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }

  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
  }

  .user-profile img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }

  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }

  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 16px;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover {
    transform: scale(1.05);
  }
  button:active {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  button:disabled:hover {
    transform: none;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .matchItem .playerInfo img {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
  }
  .matchItem button:hover {
    transform: scale(1.1);
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
  .no-matches {
    text-align: center;
    color: #888;
    padding: 20px;
  }
</style>
</head>
<body>
  <div class="header">
    <h1>Connect Four</h1>
    <div class="user-profile">
      <img id="userAvatar" src="https://via.placeholder.com/32" alt="User Avatar">
      <span id="username">Guest</span>
    </div>
  </div>

  <div class="menu">
    <label for="rows">Rows:</label>
    <select id="rows" name="rows"></select>

    <label for="cols">Columns:</label>
    <select id="cols" name="cols"></select>

    <label for="mode">Mode:</label>
    <select id="mode" name="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>

    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
    <button id="refreshMatchesBtn" style="margin-left: 10px;">ðŸ”„ Refresh Matches</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas" width="490" height="420"></canvas>
  <div id="status">Click "Create Game" to start playing!</div>

  <div id="matchList">
    <h3>Available Matches</h3>
    <div id="matchesContainer">No matches available.</div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const refreshBtn = document.getElementById('refreshMatchesBtn');
  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';
  let matches = {}; // global matches datastore simulation

  // Discord Embedded SDK user profile
  let currentUser = {
    id: 'local_user_' + Math.random().toString(36).substr(2, 6),
    username: 'Guest',
    avatar: 'https://via.placeholder.com/32'
  };

  // Initialize Discord Embedded SDK
  async function initDiscord() {
    if (window.Discord) {
      try {
        await Discord.init();
        const user = await Discord.getUser();
        currentUser = {
          id: user.id,
          username: user.username,
          avatar: user.avatar ? `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png` : 'https://via.placeholder.com/32'
        };
        updateUserProfile();
        loadMatchesFromStorage();
      } catch {
        updateUserProfile();
        loadMatchesFromStorage();
      }
    } else {
      updateUserProfile();
      loadMatchesFromStorage();
    }
  }

  function updateUserProfile() {
    document.getElementById('username').textContent = currentUser.username;
    document.getElementById('userAvatar').src = currentUser.avatar;
  }

  function saveMatchesToStorage() {
    localStorage.setItem('connectFourMatches', JSON.stringify(matches));
  }

  function loadMatchesFromStorage() {
    const stored = localStorage.getItem('connectFourMatches');
    if (stored) {
      matches = JSON.parse(stored);
      cleanupOldMatches();
    } else {
      matches = {};
    }
    renderMatchList();
  }

  function cleanupOldMatches() {
    const now = Date.now();
    let changed = false;
    for (const id in matches) {
      if (now - matches[id].created > 300000) {
        delete matches[id];
        changed = true;
      }
    }
    if (changed) saveMatchesToStorage();
  }

  function toggleAIDifficulty(show) {
    aiDifficultyDiv.style.display = show ? 'flex' : 'none';
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    if (board.length > 0) {
      drawBoard();
    }
  }

  function setStatus(text) {
    statusText.textContent = text;
  }

  function updateUIButtons() {
    const isGameActive = gameState === 'playing' || gameState === 'waiting' || gameState === 'ended';
    leaveBtn.disabled = !isGameActive;
    createBtn.disabled = gameState === 'playing' || gameState === 'waiting';

    rowSel.disabled = isGameActive;
    colSel.disabled = isGameActive;
    modeSel.disabled = isGameActive;
  }

  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let r=0; r<rows; r++) {
      for(let c=0; c<cols; c++) {
        ctx.fillStyle = '#222';
        ctx.fillRect(c*70, r*70, 70, 70);

        ctx.beginPath();
        ctx.arc(c*70 + 35, r*70 + 35, 28, 0, 2*Math.PI);
        if (board[r][c] === PLAYER_RED) ctx.fillStyle = '#ff4444';
        else if (board[r][c] === PLAYER_YELLOW) ctx.fillStyle = '#ffff44';
        else ctx.fillStyle = '#555';
        ctx.fill();
      }
    }
  }

  function findAvailableRow(col) {
    for(let r=rows-1; r>=0; r--) {
      if (board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  function checkWin(player) {
    for(let r=0; r<rows; r++) {
      for(let c=0; c<cols; c++) {
        if (board[r][c] !== player) continue;
        if (c + 3 < cols &&
            board[r][c+1] === player &&
            board[r][c+2] === player &&
            board[r][c+3] === player) return true;
        if (r + 3 < rows &&
            board[r+1][c] === player &&
            board[r+2][c] === player &&
            board[r+3][c] === player) return true;
        if (r + 3 < rows && c + 3 < cols &&
            board[r+1][c+1] === player &&
            board[r+2][c+2] === player &&
            board[r+3][c+3] === player) return true;
        if (r - 3 >= 0 && c + 3 < cols &&
            board[r-1][c+1] === player &&
            board[r-2][c+2] === player &&
            board[r-3][c+3] === player) return true;
      }
    }
    return false;
  }

  function isBoardFull() {
    for(let r=0; r<rows; r++) {
      for(let c=0; c<cols; c++) {
        if (board[r][c] === PLAYER_NONE) return false;
      }
    }
    return true;
  }

  function aiMove() {
    let availableCols = [];
    for(let c=0; c<cols; c++) {
      if (findAvailableRow(c) !== -1) availableCols.push(c);
    }
    if (availableCols.length === 0) return;

    const col = availableCols[Math.floor(Math.random()*availableCols.length)];
    const row = findAvailableRow(col);
    board[row][col] = PLAYER_YELLOW;
    drawBoard();
    if (checkWin(PLAYER_YELLOW)) {
      setStatus('AI Wins!');
      gameState = 'ended';
      updateUIButtons();
      return;
    }
    if (isBoardFull()) {
      setStatus('Game Draw!');
      gameState = 'ended';
      updateUIButtons();
      return;
    }
    currentPlayer = PLAYER_RED;
    setStatus("Your turn");
  }

  function handlePlayerMove(col) {
    if (gameState !== 'playing' || currentPlayer !== myPlayer) return;
    const row = findAvailableRow(col);
    if (row === -1) return;
    board[row][col] = currentPlayer;
    drawBoard();

    if (checkWin(currentPlayer)) {
      setStatus((currentPlayer === PLAYER_RED ? 'Red' : 'Yellow') + ' wins!');
      gameState = 'ended';
      updateUIButtons();
      return;
    }
    if (isBoardFull()) {
      setStatus('Game Draw!');
      gameState = 'ended';
      updateUIButtons();
      return;
    }

    if (gameMode === 'ai') {
      currentPlayer = PLAYER_YELLOW;
      setStatus("AI's turn...");
      setTimeout(aiMove, 600);
    } else {
      currentPlayer = (currentPlayer === PLAYER_RED) ? PLAYER_YELLOW : PLAYER_RED;
      setStatus((currentPlayer === PLAYER_RED ? 'Red' : 'Yellow') + "'s turn");
    }
  }

  canvas.addEventListener('click', (e) => {
    if (gameState !== 'playing') return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const col = Math.floor(x / 70);

    if (gameMode === 'pvp') {
      handlePlayerMove(col);
    }
  });

  rowSel.addEventListener('change', e => {
    rows = parseInt(e.target.value);
    initBoard();
  });

  colSel.addEventListener('change', e => {
    cols = parseInt(e.target.value);
    initBoard();
  });

  modeSel.addEventListener('change', e => {
    gameMode = e.target.value;
    toggleAIDifficulty(gameMode === 'ai');
  });

  aiButtons.forEach(btn => {
    btn.addEventListener('click', e => {
      aiButtons.forEach(b => b.classList.remove('active'));
      e.target.classList.add('active');
      aiDifficulty = e.target.dataset.level;
    });
  });

  function generateGameId() {
    return 'game_' + Math.random().toString(36).substr(2, 9);
  }

  function createGame() {
    if (gameState === 'playing' || gameState === 'waiting') return;

    if (gameId) {
      // Leave previous game to prevent multiple matches owned
      leaveGame();
    }

    gameId = generateGameId();
    currentGame = {
      id: gameId,
      ownerId: currentUser.id,
      ownerInfo: { username: currentUser.username, avatar: currentUser.avatar },
      rows,
      cols,
      mode: gameMode,
      created: Date.now(),
      players: [currentUser.id],
      status: 'waiting' // waiting, playing, ended
    };
    matches[gameId] = currentGame;
    saveMatchesToStorage();
    renderMatchList();

    myPlayer = PLAYER_RED;
    currentPlayer = PLAYER_RED;
    gameState = 'playing';
    initBoard();
    setStatus('Game created. Your turn.');
    updateUIButtons();
  }

  function leaveGame() {
    if (!gameId) return;
    if (matches[gameId]) {
      delete matches[gameId];
      saveMatchesToStorage();
    }
    gameId = null;
    currentGame = null;
    gameState = 'idle';
    myPlayer = PLAYER_NONE;
    currentPlayer = PLAYER_RED;
    setStatus('You left the game.');
    updateUIButtons();
    renderMatchList();
  }

  function joinGame(id) {
    if (!matches[id]) return alert("Match not found or expired.");
    if (matches[id].ownerId === currentUser.id) return alert("You cannot join your own match.");
    if (gameState === 'playing') return alert("You are already in a game.");

    if (gameId) {
      leaveGame(); // leave any existing game first, which deletes it
    }

    gameId = id;
    currentGame = matches[id];
    myPlayer = PLAYER_YELLOW; // joiner is yellow
    rows = currentGame.rows;
    cols = currentGame.cols;
    gameMode = currentGame.mode;

    initBoard();
    gameState = 'playing';
    currentPlayer = PLAYER_RED; // owner starts first
    setStatus("Joined game. Red player's turn.");
    updateUIButtons();

    // Remove the match from available (mark as started)
    delete matches[id];
    saveMatchesToStorage();
    renderMatchList();
  }

  function renderMatchList() {
    matchesContainer.innerHTML = '';
    const ids = Object.keys(matches);

    // Remove expired and your own matches
    cleanupOldMatches();

    const filteredIds = ids.filter(id => {
      return matches[id] && matches[id].ownerId !== currentUser.id;
    });

    if (filteredIds.length === 0) {
      matchesContainer.innerHTML = '<div class="no-matches">No matches available.</div>';
      return;
    }

    filteredIds.forEach(id => {
      const match = matches[id];

      const div = document.createElement('div');
      div.className = 'matchItem';

      const playerInfo = document.createElement('div');
      playerInfo.className = 'playerInfo';

      const avatar = document.createElement('img');
      avatar.src = match.ownerInfo?.avatar || 'https://via.placeholder.com/28';
      avatar.alt = 'Owner Avatar';

      const name = document.createElement('span');
      name.textContent = match.ownerInfo?.username || 'Unknown';

      playerInfo.appendChild(avatar);
      playerInfo.appendChild(name);

      const btn = document.createElement('button');
      btn.textContent = 'Join';
      btn.addEventListener('click', () => {
        joinGame(id);
      });

      div.appendChild(playerInfo);
      div.appendChild(btn);

      matchesContainer.appendChild(div);
    });
  }

  refreshBtn.addEventListener('click', () => {
    loadMatchesFromStorage();
    setStatus('Match list refreshed.');
  });

  createBtn.addEventListener('click', createGame);
  leaveBtn.addEventListener('click', leaveGame);

  function populateSelects() {
    rowSel.innerHTML = '';
    colSel.innerHTML = '';
    for(let i=4; i<=12; i++) {
      const rowOpt = document.createElement('option');
      rowOpt.value = i;
      rowOpt.textContent = i;
      if(i === rows) rowOpt.selected = true;
      rowSel.appendChild(rowOpt);

      const colOpt = document.createElement('option');
      colOpt.value = i;
      colOpt.textContent = i;
      if(i === cols) colOpt.selected = true;
      colSel.appendChild(colOpt);
    }
  }

  populateSelects();
  toggleAIDifficulty(gameMode === 'ai');
  initBoard();
  initDiscord();

});
</script>

<!-- Discord Embedded SDK must be loaded separately for Discord.init and Discord.getUser() -->
<script src="https://discord.com/assets/sdk.js"></script>

</body>
</html>
