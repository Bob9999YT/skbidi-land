<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four Multiplayer + AI</title>
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }
  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
    user-select: none;
  }
  .user-profile .avatar-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ffaa00;
    color: #111;
    font-weight: 700;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-transform: uppercase;
    overflow: hidden;
  }
  .user-profile .avatar-circle img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }
  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }
  #matchList {
    max-width: 600px;
    width: 100%;
    margin-top: 10px;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
    padding: 8px;
    background: #1f1f2b;
    border: 1.5px solid #ffaa00;
    border-radius: 6px;
  }
  .matchItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 8px;
    border-bottom: 1px solid #444;
  }
  .matchItem:last-child {
    border-bottom: none;
  }
  .matchPlayers {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .playerEntry {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    color: #ffaa00;
  }
  .playerEntry .avatar-circle {
    width: 24px;
    height: 24px;
    font-size: 14px;
    flex-shrink: 0;
  }
  button {
    background-color: #ffaa00;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: 600;
    cursor: pointer;
  }
  button:disabled {
    background-color: #555;
    cursor: default;
  }
  #aiDifficultyButtons {
    margin-top: 10px;
    display: none;
    gap: 8px;
  }
  #aiDifficultyButtons button {
    padding: 4px 8px;
    font-weight: 600;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    background: #444;
    color: #fff;
  }
  #aiDifficultyButtons button.active {
    background-color: #ffaa00;
    color: black;
  }
  canvas {
    margin-top: 15px;
    background-color: #ffaa00;
    border-radius: 10px;
    cursor: pointer;
  }
  #status {
    margin-top: 15px;
    text-align: center;
    font-weight: 600;
    min-height: 30px;
  }
  .hide {
    display: none !important;
  }
</style>
</head>
<body>

<!-- Username prompt -->
<div id="usernamePromptContainer" style="max-width: 400px; width: 100%;">
  <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
  <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <input id="avatarUrlInput" type="text" placeholder="Avatar Image/GIF URL (optional)"
         style="width: 100%; padding: 8px; margin-bottom: 15px; border: 2px solid #ffaa00; border-radius: 6px; background:#29293d; color:white;" />
  <button id="usernameSubmit" disabled style="width: 100%;">Start Playing</button>
</div>

<!-- Header -->
<div class="header hide">
  <h1>Connect Four</h1>
  <div class="user-profile">
    <div class="avatar-circle" id="userAvatar"></div>
    <span id="usernameDisplay">Guest</span>
  </div>
</div>

<!-- Menu -->
<div class="menu hide" style="max-width: 600px; width: 100%; margin-top: 10px; gap: 12px; display: flex; flex-wrap: wrap; align-items: center;">
  <label style="color: #ffaa00; font-weight: 600;">Rows:
    <select id="rows"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Columns:
    <select id="cols"></select>
  </label>
  <label style="color: #ffaa00; font-weight: 600;">Mode:
    <select id="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>
  </label>
  <button id="create">Create Game</button>
  <button id="leave" disabled>Leave Game</button>
</div>

<!-- AI difficulty -->
<div id="aiDifficultyButtons" class="hide" style="max-width: 600px; width: 100%; justify-content: center; gap: 8px;">
  <button data-level="easy">Easy</button>
  <button data-level="normal" class="active">Normal</button>
  <button data-level="hard">Hard</button>
  <button data-level="insane">Insane</button>
  <button data-level="impossible">Impossible</button>
</div>

<!-- Canvas -->
<canvas id="gameCanvas" width="490" height="420" class="hide"></canvas>

<!-- Status -->
<div id="status" class="hide"></div>

<!-- Match List -->
<div id="matchList" class="hide" style="max-width: 600px; width: 100%; margin-top: 10px;">
  <h3 style="color:#ffaa00; text-align:center;">Available Matches</h3>
  <button id="refreshMatchesBtn">Refresh Matches</button>
  <div id="matchesContainer">
    <div class="no-matches" style="text-align:center; color:#888;">No matches available.</div>
  </div>
</div>

<script>
(() => {
  const PLAYER_NONE=0, PLAYER_RED=1, PLAYER_YELLOW=2;

  let currentUser = { username: null, avatarUrl: null, id: null };
  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';
  let isInMatch = false;

  const STORAGE_KEY = 'connect_four_global_matches';
  const matches = {};

  // DOM Elements
  const usernamePrompt = document.getElementById('usernamePromptContainer');
  const usernameInput = document.getElementById('usernameInput');
  const avatarUrlInput = document.getElementById('avatarUrlInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const header = document.querySelector('.header');
  const userAvatarDiv = document.getElementById('userAvatar');
  const usernameDisplay = document.getElementById('usernameDisplay');
  const menu = document.querySelector('.menu');
  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDiv = document.getElementById('aiDifficultyButtons');
  const aiBtns = aiDiv.querySelectorAll('button');
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusDiv = document.getElementById('status');
  const matchListDiv = document.getElementById('matchList');
  const matchesContainer = document.getElementById('matchesContainer');
  const refreshMatchesBtn = document.getElementById('refreshMatchesBtn');

  // Utils
  function generateId() {
    return 'game_' + Math.random().toString(36).slice(2,10);
  }
  function createAvatarCircle(name, url) {
    if(url){
      return `<img src="${url}" alt="${name}" title="${name}"/>`;
    } else {
      const initial = name.charAt(0).toUpperCase();
      return `<div class="avatar-circle">${initial}</div>`;
    }
  }
  function setAvatarDiv(div, name, url){
    if(url){
      div.innerHTML = `<img src="${url}" alt="${name}">`;
    } else {
      div.textContent = name.charAt(0).toUpperCase();
    }
  }
  function saveMatches() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
  }
  function loadMatches() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      try {
        const obj = JSON.parse(raw);
        if(typeof obj === 'object' && obj !== null){
          for(const key in obj){
            matches[key] = obj[key];
          }
        }
      } catch {}
    }
  }
  function clearMatches() {
    for(const key in matches){
      delete matches[key];
    }
    saveMatches();
  }

  // Board init and drawing
  function initBoard() {
    board = [];
    for(let r=0;r<rows;r++){
      board[r] = [];
      for(let c=0;c<cols;c++){
        board[r][c] = PLAYER_NONE;
      }
    }
  }
  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const slotSize = 70;
    canvas.width = cols*slotSize;
    canvas.height = rows*slotSize;
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = c*slotSize + slotSize/2;
        const y = r*slotSize + slotSize/2;
        ctx.beginPath();
        ctx.arc(x,y,slotSize/2 - 6,0,Math.PI*2);
        if(board[r][c] === PLAYER_NONE){
          ctx.fillStyle = '#29293d';
        } else if(board[r][c] === PLAYER_RED){
          ctx.fillStyle = 'red';
        } else if(board[r][c] === PLAYER_YELLOW){
          ctx.fillStyle = 'yellow';
        }
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  // Check for a win
  function checkWin(player){
    // horizontal, vertical, diagonal checks
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(board[r][c] === player){
          // horiz
          if(c+3 < cols && board[r][c+1]===player && board[r][c+2]===player && board[r][c+3]===player) return true;
          // vert
          if(r+3 < rows && board[r+1][c]===player && board[r+2][c]===player && board[r+3][c]===player) return true;
          // diag down-right
          if(r+3 < rows && c+3 < cols && board[r+1][c+1]===player && board[r+2][c+2]===player && board[r+3][c+3]===player) return true;
          // diag down-left
          if(r+3 < rows && c-3 >=0 && board[r+1][c-1]===player && board[r+2][c-2]===player && board[r+3][c-3]===player) return true;
        }
      }
    }
    return false;
  }
  function checkDraw(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(board[r][c] === PLAYER_NONE) return false;
      }
    }
    return true;
  }

  // Make a move on board
  function makeMove(col, player){
    if(gameState !== 'playing') return false;
    if(player !== currentPlayer) return false;
    if(col<0 || col>=cols) return false;
    // find lowest empty slot
    for(let r=rows-1;r>=0;r--){
      if(board[r][col] === PLAYER_NONE){
        board[r][col] = player;
        return r;
      }
    }
    return false;
  }

  // Handle canvas clicks
  function onCanvasClick(e){
    if(gameState !== 'playing') return;
    if(myPlayer !== currentPlayer) return;
    const rect = canvas.getBoundingClientRect();
    const slotSize = 70;
    const x = e.clientX - rect.left;
    const col = Math.floor(x/slotSize);
    if(col<0 || col>=cols) return;
    if(board[0][col] !== PLAYER_NONE) return; // full col
    const row = makeMove(col, myPlayer);
    if(row === false) return;
    drawBoard();
    afterMove(myPlayer, col, row);
  }

  // After a move, check game end or switch turn
  function afterMove(player, col, row){
    if(checkWin(player)){
      statusDiv.textContent = (player === myPlayer ? "You win!" : (gameMode === 'pvp' ? "Opponent wins!" : "AI wins!"));
      gameState = 'ended';
      leaveBtn.disabled = false;
      return;
    }
    if(checkDraw()){
      statusDiv.textContent = "Draw!";
      gameState = 'ended';
      leaveBtn.disabled = false;
      return;
    }
    currentPlayer = (currentPlayer === PLAYER_RED) ? PLAYER_YELLOW : PLAYER_RED;
    updateStatus();
    if(gameMode === 'ai' && currentPlayer !== myPlayer && gameState==='playing'){
      aiMove();
    }
  }

  // Update status text
  function updateStatus(){
    if(gameState !== 'playing'){
      return;
    }
    if(gameMode === 'pvp'){
      if(currentPlayer === myPlayer){
        statusDiv.textContent = "Your turn!";
      } else {
        statusDiv.textContent = "Opponent's turn...";
      }
    } else {
      statusDiv.textContent = (currentPlayer === myPlayer) ? "Your turn!" : "AI is thinking...";
    }
  }

  // AI logic by difficulty
  async function aiMove(){
    // Wait a bit to simulate thinking
    statusDiv.textContent = "AI is thinking...";
    await new Promise(r=>setTimeout(r, 700));
    // Pick a column according to difficulty
    let col;
    switch(aiDifficulty){
      case 'easy':
        col = aiRandomMove();
        break;
      case 'normal':
        col = aiNormalMove();
        break;
      case 'hard':
        col = aiHardMove();
        break;
      case 'insane':
        col = aiInsaneMove();
        break;
      case 'impossible':
        col = aiImpossibleMove();
        break;
      default:
        col = aiRandomMove();
    }
    const row = makeMove(col, PLAYER_YELLOW);
    drawBoard();
    afterMove(PLAYER_YELLOW, col, row);
  }

  // AI move helpers (very simple heuristics)

  // Easy: random valid column
  function aiRandomMove(){
    const validCols = [];
    for(let c=0;c<cols;c++){
      if(board[0][c]===PLAYER_NONE) validCols.push(c);
    }
    return validCols[Math.floor(Math.random()*validCols.length)];
  }

  // Normal: try to win if possible, else random
  function aiNormalMove(){
    // Try winning move
    for(let c=0;c<cols;c++){
      if(board[0][c]!==PLAYER_NONE) continue;
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_YELLOW;
      if(checkWin(PLAYER_YELLOW)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    // Else block opponent if possible
    for(let c=0;c<cols;c++){
      if(board[0][c]!==PLAYER_NONE) continue;
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_RED;
      if(checkWin(PLAYER_RED)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    return aiRandomMove();
  }

  // Hard: normal + prefer center column if available
  function aiHardMove(){
    const center = Math.floor(cols/2);
    if(board[0][center] === PLAYER_NONE){
      return center;
    }
    return aiNormalMove();
  }

  // Insane: tries to prevent player winning, tries winning, then random
  function aiInsaneMove(){
    // Block opponent winning two moves ahead
    for(let c=0;c<cols;c++){
      if(board[0][c]!==PLAYER_NONE) continue;
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_RED;
      let willWin = false;
      for(let cc=0;cc<cols;cc++){
        if(board[0][cc]!==PLAYER_NONE) continue;
        let rr = getAvailableRow(cc);
        if(rr === -1) continue;
        board[rr][cc] = PLAYER_RED;
        if(checkWin(PLAYER_RED)){
          willWin = true;
        }
        board[rr][cc] = PLAYER_NONE;
      }
      board[r][c] = PLAYER_NONE;
      if(willWin){
        return c;
      }
    }
    return aiHardMove();
  }

  // Impossible: perfect play - minimax or immediate block/win (simplified)
  function aiImpossibleMove(){
    // Try winning move
    for(let c=0;c<cols;c++){
      if(board[0][c]!==PLAYER_NONE) continue;
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_YELLOW;
      if(checkWin(PLAYER_YELLOW)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    // Block opponent winning move
    for(let c=0;c<cols;c++){
      if(board[0][c]!==PLAYER_NONE) continue;
      let r = getAvailableRow(c);
      if(r === -1) continue;
      board[r][c] = PLAYER_RED;
      if(checkWin(PLAYER_RED)){
        board[r][c] = PLAYER_NONE;
        return c;
      }
      board[r][c] = PLAYER_NONE;
    }
    // Center column preferred
    const center = Math.floor(cols/2);
    if(board[0][center] === PLAYER_NONE) return center;

    // Else fallback to normal
    return aiNormalMove();
  }

  function getAvailableRow(col){
    for(let r=rows-1;r>=0;r--){
      if(board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  // Multiplayer match management (localStorage-based for demo)
  function saveMatch(match){
    matches[match.id] = match;
    saveMatches();
    renderMatchList();
  }
  function deleteMatch(id){
    delete matches[id];
    saveMatches();
    renderMatchList();
  }

  // Render available matches for PvP
  function renderMatchList(){
    if(isInMatch) {
      matchListDiv.classList.add('hide');
      return;
    }
    matchListDiv.classList.remove('hide');
    matchesContainer.innerHTML = '';
    let foundAny = false;
    for(const id in matches){
      const m = matches[id];
      if(m.mode !== 'pvp') continue;
      if(m.status === 'ended') continue;
      foundAny = true;
      const div = document.createElement('div');
      div.classList.add('matchItem');
      const playerDiv = document.createElement('div');
      playerDiv.classList.add('matchPlayers');
      // Owner
      const ownerDiv = document.createElement('div');
      ownerDiv.classList.add('playerEntry');
      ownerDiv.innerHTML = `
        <div class="avatar-circle">${m.owner.username.charAt(0).toUpperCase()}</div>
        <span>${m.owner.username}</span>
      `;
      playerDiv.appendChild(ownerDiv);
      // Opponent if exists
      if(m.opponent){
        const oppDiv = document.createElement('div');
        oppDiv.classList.add('playerEntry');
        oppDiv.innerHTML = `
          <div class="avatar-circle">${m.opponent.username.charAt(0).toUpperCase()}</div>
          <span>${m.opponent.username}</span>
        `;
        playerDiv.appendChild(oppDiv);
      }
      div.appendChild(playerDiv);

      // Status text
      const statusSpan = document.createElement('span');
      if(!m.opponent){
        statusSpan.textContent = 'Waiting for opponent to join...';
      } else {
        statusSpan.textContent = `${m.opponent.username} joined! Your turn!`;
      }
      div.appendChild(statusSpan);

      // Join button if available
      if(!m.opponent && currentUser.id !== m.owner.id){
        const joinBtn = document.createElement('button');
        joinBtn.textContent = 'Join';
        joinBtn.onclick = () => {
          joinMatch(id);
        };
        div.appendChild(joinBtn);
      }
      matchesContainer.appendChild(div);
    }
    if(!foundAny){
      const noMatchesDiv = document.createElement('div');
      noMatchesDiv.classList.add('no-matches');
      noMatchesDiv.textContent = 'No matches available.';
      matchesContainer.appendChild(noMatchesDiv);
    }
  }

  // Create a new match
  function createMatch(){
    if(isInMatch) return;
    gameId = generateId();
    currentPlayer = PLAYER_RED;
    initBoard();
    drawBoard();
    statusDiv.textContent = (myPlayer === PLAYER_RED) ? "Your turn!" : "Opponent's turn...";
    isInMatch = true;
    gameState = 'playing';
    leaveBtn.disabled = false;

    if(gameMode === 'pvp'){
      matches[gameId] = {
        id: gameId,
        owner: {...currentUser},
        opponent: null,
        board: JSON.parse(JSON.stringify(board)),
        currentPlayer: PLAYER_RED,
        mode: 'pvp',
        status: 'waiting',
      };
      saveMatches();
      renderMatchList();
      matchListDiv.classList.add('hide');
      canvas.classList.remove('hide');
      statusDiv.classList.remove('hide');
    } else {
      // AI Mode
      canvas.classList.remove('hide');
      statusDiv.classList.remove('hide');
      isInMatch = true;
      gameState = 'playing';
      myPlayer = PLAYER_RED;
      updateStatus();
    }
  }

  // Join existing PvP match
  function joinMatch(id){
    if(isInMatch) return;
    const match = matches[id];
    if(!match) return alert('Match no longer exists.');
    if(match.opponent) return alert('Match already has opponent.');
    match.opponent = {...currentUser};
    match.status = 'playing';
    saveMatches();
    gameId = id;
    board = JSON.parse(JSON.stringify(match.board));
    currentPlayer = match.currentPlayer;
    myPlayer = PLAYER_YELLOW;
    isInMatch = true;
    gameState = 'playing';

    matchListDiv.classList.add('hide');
    canvas.classList.remove('hide');
    statusDiv.classList.remove('hide');
    leaveBtn.disabled = false;
    drawBoard();

    // Notify owner (simulate)
    updateStatus();

    // Start the game, ownerâ€™s turn is red, your turn yellow
    if(currentPlayer === myPlayer) {
      statusDiv.textContent = "Your turn!";
    } else {
      statusDiv.textContent = "Opponent's turn...";
    }
  }

  // Leave match
  function leaveMatch(){
    if(!isInMatch) return;
    if(gameMode === 'pvp'){
      // Remove self from match
      if(matches[gameId]){
        if(matches[gameId].owner.id === currentUser.id){
          // Owner leaves, delete match
          deleteMatch(gameId);
        } else if(matches[gameId].opponent && matches[gameId].opponent.id === currentUser.id){
          // Opponent leaves
          matches[gameId].opponent = null;
          matches[gameId].status = 'waiting';
          saveMatches();
          renderMatchList();
        }
      }
    }
    isInMatch = false;
    gameId = null;
    gameState = 'idle';
    myPlayer = PLAYER_NONE;
    currentPlayer = PLAYER_RED;
    initBoard();
    drawBoard();
    statusDiv.textContent = '';
    leaveBtn.disabled = true;
    canvas.classList.add('hide');
    if(gameMode === 'pvp'){
      matchListDiv.classList.remove('hide');
      renderMatchList();
    }
  }

  // Handle board updates after player move in PvP
  function updateMatchBoard(col, row){
    if(!gameId) return;
    if(gameMode !== 'pvp') return;
    if(!matches[gameId]) return;
    matches[gameId].board = JSON.parse(JSON.stringify(board));
    matches[gameId].currentPlayer = currentPlayer;
    saveMatches();
    renderMatchList();
  }

  // User move in PvP mode
  function playerMovePvP(col){
    if(gameState !== 'playing') return;
    if(myPlayer !== currentPlayer) return;
    if(board[0][col] !== PLAYER_NONE) return;
    const row = makeMove(col, myPlayer);
    if(row === false) return;
    drawBoard();
    updateMatchBoard(col, row);
    afterMove(myPlayer, col, row);
  }

  // Listen for storage events to sync matches and moves
  window.addEventListener('storage', (e) => {
    if(e.key === STORAGE_KEY){
      loadMatches();
      if(gameMode === 'pvp' && isInMatch && matches[gameId]){
        const match = matches[gameId];
        if(match.opponent && myPlayer === PLAYER_RED){
          // Opponent joined
          statusDiv.textContent = `${match.opponent.username} joined! Your turn!`;
          matchListDiv.classList.add('hide');
          if(gameState !== 'playing'){
            gameState = 'playing';
            leaveBtn.disabled = false;
          }
        }
        if(match.board){
          // Update board state for PvP
          board = JSON.parse(JSON.stringify(match.board));
          currentPlayer = match.currentPlayer;
          drawBoard();
          updateStatus();
        }
      }
      renderMatchList();
    }
  });

  // Canvas click handler for PvP and AI
  canvas.addEventListener('click', (e) => {
    if(gameState !== 'playing') return;
    if(gameMode === 'pvp'){
      playerMovePvP(Math.floor((e.clientX - canvas.getBoundingClientRect().left)/70));
    } else if(gameMode === 'ai'){
      if(myPlayer === currentPlayer){
        const col = Math.floor((e.clientX - canvas.getBoundingClientRect().left)/70);
        if(col < 0 || col >= cols) return;
        if(board[0][col] !== PLAYER_NONE) return;
        const row = makeMove(col, myPlayer);
        if(row === false) return;
        drawBoard();
        afterMove(myPlayer, col, row);
      }
    }
  });

  // Fill rows and cols selects
  function fillRowsCols(){
    rowSel.innerHTML = '';
    colSel.innerHTML = '';
    for(let i=4;i<=8;i++){
      const rOpt = document.createElement('option');
      rOpt.value = i;
      rOpt.textContent = i;
      if(i === rows) rOpt.selected = true;
      rowSel.appendChild(rOpt);

      const cOpt = document.createElement('option');
      cOpt.value = i;
      cOpt.textContent = i;
      if(i === cols) cOpt.selected = true;
      colSel.appendChild(cOpt);
    }
  }

  // Update mode change
  function onModeChange(){
    gameMode = modeSel.value;
    if(gameMode === 'ai'){
      aiDiv.style.display = 'flex';
      matchListDiv.classList.add('hide');
    } else {
      aiDiv.style.display = 'none';
      if(!isInMatch) matchListDiv.classList.remove('hide');
    }
  }

  // AI difficulty button handlers
  aiBtns.forEach(btn=>{
    btn.addEventListener('click', () => {
      aiBtns.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.getAttribute('data-level');
    });
  });

  // Username input validation
  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim().length === 0;
  });
  usernameSubmit.addEventListener('click', () => {
    const name = usernameInput.value.trim();
    if(!name) return;
    currentUser.username = name;
    currentUser.avatarUrl = avatarUrlInput.value.trim() || null;
    currentUser.id = generateId(); // Unique id per session

    usernamePrompt.classList.add('hide');
    header.classList.remove('hide');
    menu.classList.remove('hide');
    matchListDiv.classList.remove('hide');

    usernameDisplay.textContent = currentUser.username;
    if(currentUser.avatarUrl){
      userAvatarDiv.innerHTML = `<img src="${currentUser.avatarUrl}" alt="${currentUser.username}">`;
    } else {
      userAvatarDiv.textContent = currentUser.username.charAt(0).toUpperCase();
    }
    fillRowsCols();
    renderMatchList();
  });

  // Mode select change
  modeSel.addEventListener('change', () => {
    onModeChange();
  });

  // Rows, cols change handlers
  rowSel.addEventListener('change', () => {
    rows = parseInt(rowSel.value,10);
    initBoard();
    drawBoard();
  });
  colSel.addEventListener('change', () => {
    cols = parseInt(colSel.value,10);
    initBoard();
    drawBoard();
  });

  // Create button
  createBtn.addEventListener('click', () => {
    rows = parseInt(rowSel.value,10);
    cols = parseInt(colSel.value,10);
    gameMode = modeSel.value;
    myPlayer = PLAYER_RED;
    initBoard();
    drawBoard();
    createMatch();
    if(gameMode === 'pvp'){
      matchListDiv.classList.add('hide');
    } else {
      aiDiv.style.display = 'flex';
    }
    statusDiv.classList.remove('hide');
    leaveBtn.disabled = false;
  });

  // Leave button
  leaveBtn.addEventListener('click', () => {
    leaveMatch();
    if(!isInMatch){
      matchListDiv.classList.remove('hide');
      statusDiv.classList.add('hide');
      canvas.classList.add('hide');
    }
  });

  // Refresh matches button
  refreshMatchesBtn.addEventListener('click', () => {
    loadMatches();
    renderMatchList();
  });

  // Initialize
  function init(){
    loadMatches();
    initBoard();
    drawBoard();
    updateStatus();
    onModeChange();
  }

  init();

})();
</script>

</body>
</html>
