<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four Discord Activity</title>
<style>
  /* Reset and base */
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e1e2f 0%, #29293d 100%);
    color: #eee;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-y: auto;
    -webkit-font-smoothing: antialiased;
  }

  h1 {
    margin-top: 20px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #ffaa00;
    opacity: 0;
    transform: translateY(-20px);
    animation: fadeSlideIn 0.6s forwards;
    animation-delay: 0.1s;
  }

  /* Animation keyframes */
  @keyframes fadeSlideIn {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  @keyframes fadeSlideOut {
    to {
      opacity: 0;
      transform: translateY(-20px);
    }
  }

  /* Container fade/slide */
  .fade-slide {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.35s ease, transform 0.35s ease;
  }
  .fade-slide.show {
    opacity: 1;
    transform: translateY(0);
  }
  .fade-slide.hide {
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
  }

  /* Input and buttons */
  input[type="text"] {
    padding: 12px 15px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    width: 280px;
    margin-bottom: 12px;
    outline-offset: 2px;
    outline-color: #ffaa00;
    transition: box-shadow 0.3s ease;
  }
  input[type="text"]:focus {
    box-shadow: 0 0 10px #ffaa00;
  }

  button {
    background: #ffaa00;
    color: #222;
    border: none;
    border-radius: 8px;
    padding: 10px 18px;
    font-size: 16px;
    cursor: pointer;
    font-weight: 700;
    letter-spacing: 0.05em;
    transition: background-color 0.25s ease, transform 0.2s ease;
    user-select: none;
    box-shadow: 0 4px 8px rgb(255 170 0 / 0.4);
  }
  button:hover:not(:disabled) {
    background: #ffbb33;
    transform: translateY(-2px);
    box-shadow: 0 6px 14px rgb(255 187 51 / 0.6);
  }
  button:active:not(:disabled) {
    transform: translateY(1px);
    box-shadow: 0 3px 6px rgb(255 170 0 / 0.3);
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
    box-shadow: none;
  }

  select {
    padding: 10px 15px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    margin-left: 10px;
    outline-offset: 2px;
    outline-color: #ffaa00;
    cursor: pointer;
    box-shadow: 0 4px 8px rgb(255 170 0 / 0.4);
    transition: box-shadow 0.3s ease;
  }
  select:hover {
    box-shadow: 0 6px 12px rgb(255 170 0 / 0.6);
  }

  /* Container layouts */
  #usernamePrompt,
  #menu,
  #matchList,
  #status {
    margin-top: 15px;
    width: 350px;
    max-width: 90vw;
  }

  #menu {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  #aiDifficultyButtons {
    display: flex;
    gap: 8px;
    margin-top: 4px;
    flex-wrap: wrap;
  }

  #aiDifficultyButtons button {
    flex-grow: 1;
    font-weight: 600;
  }
  #aiDifficultyButtons button.active {
    background: #ffdd55;
    color: #222;
    box-shadow: 0 6px 14px rgb(255 221 85 / 0.8);
  }

  #matchList {
    background: #29293d;
    border-radius: 12px;
    padding: 12px 15px;
    max-height: 240px;
    overflow-y: auto;
    box-shadow: 0 6px 20px rgb(0 0 0 / 0.3);
    user-select: text;
  }

  .matchItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #444;
  }
  .matchItem:last-child {
    border-bottom: none;
  }
  .matchPlayer {
    display: flex;
    align-items: center;
    gap: 12px;
    color: #ffaa00;
  }
  .avatar-circle {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: #555;
    color: #fff;
    font-weight: 700;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  #status {
    min-height: 24px;
    font-weight: 600;
    text-align: center;
    color: #ffcc00;
    letter-spacing: 0.03em;
    user-select: text;
  }

  /* Canvas styling */
  #canvas {
    margin-top: 20px;
    border-radius: 12px;
    background: #222244;
    cursor: pointer;
    box-shadow: 0 8px 24px rgba(255, 170, 0, 0.3);
    transition: box-shadow 0.3s ease;
    max-width: 100vw;
    user-select: none;
  }
  #canvas:hover {
    box-shadow: 0 12px 32px rgba(255, 187, 51, 0.6);
  }

  /* Scrollbar for matchList */
  #matchList::-webkit-scrollbar {
    width: 8px;
  }
  #matchList::-webkit-scrollbar-track {
    background: #29293d;
  }
  #matchList::-webkit-scrollbar-thumb {
    background: #ffaa00;
    border-radius: 4px;
  }

  /* Disable text selection for buttons and canvas */
  button, #canvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
</style>
</head>
<body>

<h1>Connect Four</h1>

<div id="usernamePrompt" class="fade-slide show">
  <input id="usernameInput" placeholder="Enter your username" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
  <button id="usernameSubmit" disabled>Start</button>
</div>

<div id="menu" class="fade-slide hide" aria-hidden="true">
  <label for="modeSelect" style="font-weight:600; color:#ffaa00;">Choose Mode:</label>
  <select id="modeSelect" aria-label="Game mode selector">
    <option value="pvp">Player vs Player</option>
    <option value="ai">Player vs AI</option>
  </select>

  <div id="aiDifficultyButtons" style="display:none;" aria-label="AI difficulty selection">
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <div style="margin-top: 10px;">
    <button id="createMatchBtn">Create Match</button>
    <button id="leaveMatchBtn" disabled>Leave Match</button>
    <button id="refreshMatchesBtn" style="margin-left: 10px;">ðŸ”„ Refresh Matches</button>
  </div>
</div>

<div id="status" class="fade-slide" aria-live="polite"></div>

<div id="matchList" class="fade-slide" aria-label="Available matches"></div>

<canvas id="canvas" width="420" height="360" style="display:none;" aria-label="Connect Four game board" role="img" tabindex="0"></canvas>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
(() => {
  // Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCKSyN1gTe8XvveVnDV8VzXLieaPGsQBc8",
    authDomain: "sigma-skibidi-b9e1e.firebaseapp.com",
    databaseURL: "https://sigma-skibidi-b9e1e-default-rtdb.firebaseio.com/",
    projectId: "sigma-skibidi-b9e1e",
    storageBucket: "sigma-skibidi-b9e1e.firebasestorage.app",
    messagingSenderId: "645635975542",
    appId: "1:645635975542:web:f22275c0e2b9ae00f8b257",
    measurementId: "G-G7DX318MFR"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Constants
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const ROWS = 6, COLS = 7;

  // State
  let board = [];
  let currentPlayer = PLAYER_RED;
  let myPlayer = PLAYER_NONE;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';
  let gameId = null;
  let currentUser = { id: null, username: null };
  let isInMatch = false;
  let gameState = 'idle';

  // DOM Elements
  const usernamePrompt = document.getElementById('usernamePrompt');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const menu = document.getElementById('menu');
  const modeSelect = document.getElementById('modeSelect');
  const aiDifficultyButtons = document.getElementById('aiDifficultyButtons');
  const createMatchBtn = document.getElementById('createMatchBtn');
  const leaveMatchBtn = document.getElementById('leaveMatchBtn');
  const refreshMatchesBtn = document.getElementById('refreshMatchesBtn');
  const statusDiv = document.getElementById('status');
  const matchListDiv = document.getElementById('matchList');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Animations helpers
  function fadeIn(el) {
    el.classList.remove('hide');
    el.classList.add('show');
    el.setAttribute('aria-hidden', 'false');
  }
  function fadeOut(el) {
    el.classList.remove('show');
    el.classList.add('hide');
    el.setAttribute('aria-hidden', 'true');
  }

  // Board helpers
  function initBoard(){
    board = [];
    for(let r=0; r<ROWS; r++){
      board.push(new Array(COLS).fill(PLAYER_NONE));
    }
  }

  function drawBoard(){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cellSize = canvas.width / COLS;

    ctx.fillStyle = '#222244';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const x = c * cellSize;
        const y = r * cellSize;

        // slot background
        ctx.beginPath();
        ctx.fillStyle = '#555577';
        ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2 - 6, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();

        // piece
        if(board[r][c] !== PLAYER_NONE){
          ctx.beginPath();
          ctx.fillStyle = board[r][c] === PLAYER_RED ? '#ff5555' : '#ffff77';
          ctx.shadowColor = 'rgba(0,0,0,0.6)';
          ctx.shadowBlur = 10;
          ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2 - 12, 0, Math.PI*2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.closePath();
        }
      }
    }
  }

  function placePiece(col, player){
    for(let r=ROWS-1; r>=0; r--){
      if(board[r][col] === PLAYER_NONE){
        board[r][col] = player;
        return r;
      }
    }
    return -1;
  }

  function checkWinner(player, b=board){
    const directions = [[0,1],[1,0],[1,1],[1,-1]];
    function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        if(b[r][c] !== player) continue;
        for(const [dr,dc] of directions){
          let count=1;
          for(let step=1; step<4; step++){
            const nr = r + dr*step;
            const nc = c + dc*step;
            if(inBounds(nr,nc) && b[nr][nc] === player) count++;
            else break;
          }
          if(count >= 4) return true;
        }
      }
    }
    return false;
  }

  function isBoardFull(b=board){
    for(let c=0; c<COLS; c++){
      if(b[0][c] === PLAYER_NONE) return false;
    }
    return true;
  }

  function switchPlayer(){
    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
  }

  function updateStatus(text){
    statusDiv.textContent = text || '';
  }

  function resetGame(){
    initBoard();
    drawBoard();
    currentPlayer = PLAYER_RED;
    gameState = 'idle';
    gameId = null;
    myPlayer = PLAYER_NONE;
    isInMatch = false;
    leaveMatchBtn.disabled = true;
    fadeOut(menu);
    fadeIn(usernamePrompt);
    fadeOut(matchListDiv);
    canvas.style.display = 'none';
    updateStatus('');
  }

  // Firebase match functions
  function createMatch(){
    if(isInMatch) return alert("Already in a match!");
    initBoard();
    drawBoard();
    currentPlayer = PLAYER_RED;
    gameState = gameMode === 'pvp' ? 'waiting' : 'playing';
    isInMatch = true;
    leaveMatchBtn.disabled = false;
    myPlayer = PLAYER_RED;
    fadeOut(matchListDiv);
    fadeIn(menu);

    if(gameMode === 'pvp'){
      const newMatchRef = db.ref('matches').push();
      gameId = newMatchRef.key;
      const matchData = {
        owner: currentUser,
        opponent: null,
        board: board,
        currentPlayer: currentPlayer,
        mode: 'pvp',
        status: 'waiting',
        createdAt: Date.now(),
      };
      newMatchRef.set(matchData);
      updateStatus("Waiting for opponent to join...");
      listenToMatch(gameId);
      fadeIn(canvas);
    } else if(gameMode === 'ai'){
      gameId = null;
      fadeIn(canvas);
      updateStatus("Your turn!");
      fadeOut(matchListDiv);
    }
  }

  function joinMatch(id){
    if(isInMatch) return alert("Already in a match!");
    const matchRef = db.ref('matches/'+id);
    matchRef.once('value', snapshot => {
      if(!snapshot.exists()) return alert("Match not found");
      const data = snapshot.val();
      if(data.status !== 'waiting') return alert("Match already started");
      if(data.owner.id === currentUser.id) return alert("Cannot join your own match");

      matchRef.update({
        opponent: currentUser,
        status: 'playing'
      });

      gameId = id;
      isInMatch = true;
      myPlayer = PLAYER_YELLOW;
      currentPlayer = PLAYER_RED;
      board = data.board || board;
      drawBoard();
      updateStatus("Game started! Waiting for opponent move...");
      leaveMatchBtn.disabled = false;
      fadeIn(canvas);
      fadeOut(matchListDiv);
      listenToMatch(gameId);
    });
  }

  function leaveMatch(){
    if(!isInMatch) return;
    if(gameMode === 'pvp' && gameId){
      const matchRef = db.ref('matches/'+gameId);
      matchRef.remove();
    }
    resetGame();
  }

  function updateMatchBoard(){
    if(!gameId) return;
    const matchRef = db.ref('matches/'+gameId);
    matchRef.update({
      board: board,
      currentPlayer: currentPlayer
    });
  }

  function listenToMatch(id){
    const matchRef = db.ref('matches/'+id);
    matchRef.on('value', snapshot => {
      const data = snapshot.val();
      if(!data){
        updateStatus("Match ended or canceled.");
        resetGame();
        return;
      }
      if(data.status === 'ended'){
        updateStatus("Match ended.");
        resetGame();
        return;
      }
      if(data.board){
        board = data.board;
        drawBoard();
      }
      currentPlayer = data.currentPlayer || PLAYER_RED;

      if(gameState !== 'playing') gameState = 'playing';

      if(myPlayer !== currentPlayer){
        updateStatus("Opponent's turn...");
      } else {
        updateStatus("Your turn!");
      }

      if(checkWinner(PLAYER_RED)){
        updateStatus("Red wins!");
        gameState = 'ended';
      } else if(checkWinner(PLAYER_YELLOW)){
        updateStatus("Yellow wins!");
        gameState = 'ended';
      } else if(isBoardFull()){
        updateStatus("Draw!");
        gameState = 'ended';
      }
    });
  }

  // --- AI Minimax and helpers ---

  function getValidColumns(b = board){
    const cols = [];
    for(let c=0;c<COLS;c++){
      if(b[0][c] === PLAYER_NONE) cols.push(c);
    }
    return cols;
  }

  function copyBoard(b){
    return b.map(r => r.slice());
  }

  function evaluateWindow(windowArr, player){
    let score = 0;
    const opponent = player === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
    const countPlayer = windowArr.filter(v => v === player).length;
    const countOpponent = windowArr.filter(v => v === opponent).length;
    const countEmpty = windowArr.filter(v => v === PLAYER_NONE).length;

    if(countPlayer === 4) score += 100;
    else if(countPlayer === 3 && countEmpty === 1) score += 5;
    else if(countPlayer === 2 && countEmpty === 2) score += 2;

    if(countOpponent === 3 && countEmpty === 1) score -= 4;
    return score;
  }

  function scorePosition(b, player){
    let score = 0;
    const centerArray = [];
    for(let r=0;r<ROWS;r++){
      centerArray.push(b[r][Math.floor(COLS/2)]);
    }
    const centerCount = centerArray.filter(c => c === player).length;
    score += centerCount * 3;

    // horizontal
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS-3;c++){
        const windowArr = [b[r][c],b[r][c+1],b[r][c+2],b[r][c+3]];
        score += evaluateWindow(windowArr, player);
      }
    }
    // vertical
    for(let c=0;c<COLS;c++){
      for(let r=0;r<ROWS-3;r++){
        const windowArr = [b[r][c],b[r+1][c],b[r+2][c],b[r+3][c]];
        score += evaluateWindow(windowArr, player);
      }
    }
    // positive diagonal
    for(let r=0;r<ROWS-3;r++){
      for(let c=0;c<COLS-3;c++){
        const windowArr = [b[r][c],b[r+1][c+1],b[r+2][c+2],b[r+3][c+3]];
        score += evaluateWindow(windowArr, player);
      }
    }
    // negative diagonal
    for(let r=3;r<ROWS;r++){
      for(let c=0;c<COLS-3;c++){
        const windowArr = [b[r][c],b[r-1][c+1],b[r-2][c+2],b[r-3][c+3]];
        score += evaluateWindow(windowArr, player);
      }
    }
    return score;
  }

  function isTerminalNode(b){
    return checkWinner(PLAYER_RED, b) || checkWinner(PLAYER_YELLOW, b) || isBoardFull(b);
  }

  function minimax(b, depth, alpha, beta, maximizingPlayer){
    const validLocations = getValidColumns(b);
    const isTerminal = isTerminalNode(b);

    if(depth === 0 || isTerminal){
      if(isTerminal){
        if(checkWinner(PLAYER_YELLOW, b)) return {score: 1000000000};
        else if(checkWinner(PLAYER_RED, b)) return {score: -1000000000};
        else return {score: 0};
      }
      else return {score: scorePosition(b, PLAYER_YELLOW)};
    }

    if(maximizingPlayer){
      let value = -Infinity;
      let column = validLocations[0];
      for(const col of validLocations){
        const row = getNextOpenRow(b, col);
        const bCopy = copyBoard(b);
        bCopy[row][col] = PLAYER_YELLOW;
        const newScore = minimax(bCopy, depth - 1, alpha, beta, false).score;
        if(newScore > value){
          value = newScore;
          column = col;
        }
        alpha = Math.max(alpha, value);
        if(alpha >= beta) break;
      }
      return {column, score: value};
    } else {
      let value = Infinity;
      let column = validLocations[0];
      for(const col of validLocations){
        const row = getNextOpenRow(b, col);
        const bCopy = copyBoard(b);
        bCopy[row][col] = PLAYER_RED;
        const newScore = minimax(bCopy, depth - 1, alpha, beta, true).score;
        if(newScore < value){
          value = newScore;
          column = col;
        }
        beta = Math.min(beta, value);
        if(alpha >= beta) break;
      }
      return {column, score: value};
    }
  }

  function getNextOpenRow(b, col){
    for(let r=ROWS-1;r>=0;r--){
      if(b[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  function aiMove(){
    if(gameState !== 'playing' || currentPlayer !== PLAYER_YELLOW) return;

    let col;
    let depth;
    switch(aiDifficulty){
      case 'easy': {
        const validCols = getValidColumns();
        col = validCols[Math.floor(Math.random() * validCols.length)];
        break;
      }
      case 'normal': depth = 3; break;
      case 'hard': depth = 4; break;
      case 'insane': depth = 5; break;
      case 'impossible': depth = 7; break;
      default: depth = 3;
    }
    if(depth){
      const result = minimax(board, depth, -Infinity, Infinity, true);
      col = result.column;
    }

    const row = placePiece(col, PLAYER_YELLOW);
    drawBoard();

    if(checkWinner(PLAYER_YELLOW)){
      gameState = 'ended';
      updateStatus("AI wins!");
      return;
    } else if(isBoardFull()){
      gameState = 'ended';
      updateStatus("Draw!");
      return;
    }

    switchPlayer();
    updateStatus("Your turn!");
  }

  // --- UI Event Listeners ---

  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim() === '';
  });

  usernameSubmit.addEventListener('click', () => {
    currentUser.id = 'user-' + Math.random().toString(36).slice(2, 10);
    currentUser.username = usernameInput.value.trim();
    fadeOut(usernamePrompt);
    fadeIn(menu);
    fadeIn(matchListDiv);
    canvas.style.display = 'none';
    updateStatus(`Welcome, ${currentUser.username}!`);
    renderMatchList();
  });

  modeSelect.addEventListener('change', () => {
    gameMode = modeSelect.value;
    if(gameMode === 'ai'){
      aiDifficultyButtons.style.display = 'flex';
    } else {
      aiDifficultyButtons.style.display = 'none';
    }
  });

  aiDifficultyButtons.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      aiDifficultyButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.dataset.level;
    });
  });

  createMatchBtn.addEventListener('click', () => {
    createMatch();
  });

  leaveMatchBtn.addEventListener('click', () => {
    leaveMatch();
  });

  refreshMatchesBtn.addEventListener('click', () => {
    renderMatchList();
  });

  canvas.addEventListener('click', e => {
    if(gameState !== 'playing' || currentPlayer !== myPlayer) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const colWidth = canvas.width / COLS;
    const clickedCol = Math.floor(x / colWidth);

    if(clickedCol < 0 || clickedCol >= COLS) return;
    if(board[0][clickedCol] !== PLAYER_NONE) return; // Column full

    const row = placePiece(clickedCol, currentPlayer);
    drawBoard();

    if(checkWinner(currentPlayer)){
      updateStatus(currentPlayer === PLAYER_RED ? "Red wins!" : "Yellow wins!");
      gameState = 'ended';
      if(gameMode === 'pvp' && gameId) updateMatchBoard();
      return;
    } else if(isBoardFull()){
      updateStatus("Draw!");
      gameState = 'ended';
      if(gameMode === 'pvp' && gameId) updateMatchBoard();
      return;
    }

    switchPlayer();

    if(gameMode === 'pvp' && gameId){
      updateMatchBoard();
      updateStatus("Opponent's turn...");
    } else if(gameMode === 'ai'){
      updateStatus("AI thinking...");
      setTimeout(aiMove, 400);
    }
  });

  // --- Match List ---
  function renderMatchList(){
    if(!currentUser.id) return;
    matchListDiv.innerHTML = '<h3>Available Matches</h3>';

    const matchesRef = db.ref('matches');
    matchesRef.once('value').then(snapshot => {
      const data = snapshot.val();
      matchListDiv.innerHTML = '<h3>Available Matches</h3>';
      if(!data){
        matchListDiv.innerHTML += '<p>No matches available.</p>';
        return;
      }
      let count = 0;
      for(const key in data){
        const match = data[key];
        if(match.status === 'waiting' && match.owner.id !== currentUser.id){
          count++;
          const div = document.createElement('div');
          div.className = 'matchItem';

          const ownerName = document.createElement('div');
          ownerName.className = 'matchPlayer';
          const avatar = document.createElement('div');
          avatar.className = 'avatar-circle';
          avatar.textContent = match.owner.username[0].toUpperCase();
          ownerName.appendChild(avatar);
          const usernameSpan = document.createElement('span');
          usernameSpan.textContent = match.owner.username;
          ownerName.appendChild(usernameSpan);

          const joinBtn = document.createElement('button');
          joinBtn.textContent = 'Join';
          joinBtn.onclick = () => joinMatch(key);

          div.appendChild(ownerName);
          div.appendChild(joinBtn);

          matchListDiv.appendChild(div);
        }
      }
      if(count === 0){
        matchListDiv.innerHTML += '<p>No matches available to join.</p>';
      }
    }).catch(() => {
      matchListDiv.innerHTML += '<p>Error loading matches.</p>';
    });
  }

  // --- Initialize ---
  resetGame();

})();
</script>

</body>
</html>
