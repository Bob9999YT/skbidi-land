<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }
  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }
  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
    min-width: 140px;
    justify-content: center;
  }
  .avatar-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ffaa00;
    color: #111;
    font-weight: bold;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .username-text {
    font-weight: 600;
    color: #ffaa00;
  }
  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 12px 16px;
    justify-content: center;
    align-items: center;
    margin-bottom: 20px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover:not(:disabled) {
    transform: scale(1.05);
  }
  button:active:not(:disabled) {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
  }
  button:disabled:hover {
    transform: none !important;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 20px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .matchItem .playerInfo .avatar-circle {
    width: 28px;
    height: 28px;
    font-size: 16px;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
    min-width: 70px;
  }
  .matchItem button:hover:not(:disabled) {
    transform: scale(1.1);
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
  .no-matches {
    text-align: center;
    color: #888;
    padding: 20px;
  }

  /* Username prompt modal */
  #usernameModal {
    position: fixed;
    inset: 0;
    background: #000d;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  #usernameModalContent {
    background: #29293d;
    border: 2px solid #ffaa00;
    border-radius: 12px;
    padding: 24px;
    width: 320px;
    text-align: center;
  }
  #usernameModalContent h2 {
    margin-top: 0;
    color: #ffaa00;
  }
  #usernameInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #1e1e2f;
    color: white;
    margin: 16px 0;
    box-sizing: border-box;
  }
  #usernameSubmit {
    background: #ffaa00;
    border: none;
    color: #111;
    font-weight: 700;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    width: 100%;
    font-size: 1.1rem;
    box-shadow: 0 3px 0 #bb8800;
    transition: all 0.15s ease;
  }
  #usernameSubmit:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
  }
  #usernameSubmit:hover:not(:disabled) {
    background: #e6a800;
    box-shadow: 0 5px 0 #bb8800;
  }
</style>
</head>
<body>

<div id="usernameModal">
  <div id="usernameModalContent">
    <h2>Enter Your Username</h2>
    <input id="usernameInput" type="text" maxlength="15" placeholder="Your username (3-15 chars)" />
    <button id="usernameSubmit" disabled>Continue</button>
  </div>
</div>

<div class="header" style="display:none;" id="mainUI">
  <h1>Connect Four</h1>
  <div class="user-profile">
    <div class="avatar-circle" id="avatarCircle">G</div>
    <div class="username-text" id="usernameDisplay">Guest</div>
  </div>
</div>

<div class="menu" style="display:none;" id="mainUIControls">
  <label for="rows">Rows:</label>
  <select id="rows" name="rows"></select>

  <label for="cols">Columns:</label>
  <select id="cols" name="cols"></select>

  <label for="mode">Mode:</label>
  <select id="mode" name="mode">
    <option value="pvp">Player vs Player</option>
    <option value="ai">Player vs AI</option>
  </select>

  <button id="create">Create Game</button>
  <button id="leave" disabled>Leave Game</button>
  <button id="refreshMatchesBtn">ðŸ”„ Refresh Matches</button>
</div>

<div id="aiDifficultyButtons" style="display:none;">
  <button data-level="easy">Easy</button>
  <button data-level="normal" class="active">Normal</button>
  <button data-level="hard">Hard</button>
  <button data-level="insane">Insane</button>
  <button data-level="impossible">Impossible</button>
</div>

<canvas id="gameCanvas" width="490" height="420" style="display:none;"></canvas>
<div id="status" style="max-width:600px; text-align:center; margin-top:20px; display:none;">Click "Create Game" to start playing!</div>

<div id="matchList" style="display:none;">
  <h3>Available Matches</h3>
  <div id="matchesContainer">No matches available.</div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');
  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');
  const refreshMatchesBtn = document.getElementById('refreshMatchesBtn');

  const usernameModal = document.getElementById('usernameModal');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const mainUI = document.getElementById('mainUI');
  const mainUIControls = document.getElementById('mainUIControls');
  const avatarCircle = document.getElementById('avatarCircle');
  const usernameDisplay = document.getElementById('usernameDisplay');
  const matchListDiv = document.getElementById('matchList');

  let username = '';
  let colorForUsername = '#ffaa00';

  // Game variables
  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';

  // Global matches datastore simulation
  let matches = {}; // { id: {id, players:[], state, rows, cols, mode, difficulty, created, endedAt}}

  // --- Helpers ---

  function stringToColor(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    const c = (hash & 0x00FFFFFF)
      .toString(16)
      .toUpperCase();
    return "#" + "00000".substring(0, 6 - c.length) + c;
  }

  // --- Username prompt handling ---
  usernameInput.addEventListener('input', () => {
    const val = usernameInput.value.trim();
    usernameSubmit.disabled = val.length < 3 || val.length > 15;
  });

  usernameSubmit.addEventListener('click', () => {
    const val = usernameInput.value.trim();
    if (val.length >= 3 && val.length <= 15) {
      username = val;
      colorForUsername = stringToColor(username);
      avatarCircle.textContent = username[0].toUpperCase();
      avatarCircle.style.backgroundColor = colorForUsername;
      usernameDisplay.textContent = username;
      usernameModal.style.display = 'none';
      mainUI.style.display = 'flex';
      mainUIControls.style.display = 'flex';
      canvas.style.display = 'block';
      statusText.style.display = 'block';
      matchListDiv.style.display = 'block';

      fillDropdown(rowSel, 4, 10, 6);
      fillDropdown(colSel, 4, 10, 7);
      updateAiDifficultyVisibility();
      refreshMatches();
    }
  });

  usernameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !usernameSubmit.disabled) {
      usernameSubmit.click();
      e.preventDefault();
    }
  });

  function fillDropdown(selectElem, min, max, defaultVal) {
    selectElem.innerHTML = '';
    for (let i = min; i <= max; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = i;
      if (i === defaultVal) opt.selected = true;
      selectElem.appendChild(opt);
    }
  }

  // --- Board Drawing ---
  function initBoard() {
    board = [];
    for (let r = 0; r < rows; r++) {
      board[r] = [];
      for (let c = 0; c < cols; c++) {
        board[r][c] = PLAYER_NONE;
      }
    }
  }

  function drawBoard() {
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    const cellWidth = width / cols;
    const cellHeight = height / rows;

    ctx.fillStyle = '#002266';
    ctx.fillRect(0, 0, width, height);

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let x = c * cellWidth;
        let y = r * cellHeight;
        ctx.beginPath();
        ctx.fillStyle = '#001144';
        ctx.strokeStyle = '#000022';
        ctx.lineWidth = 2;
        ctx.rect(x + 4, y + 4, cellWidth - 8, cellHeight - 8);
        ctx.fill();
        ctx.stroke();

        if (board[r][c] !== PLAYER_NONE) {
          const centerX = x + cellWidth / 2;
          const centerY = y + cellHeight / 2;
          const radius = Math.min(cellWidth, cellHeight) / 2 - 8;

          ctx.beginPath();
          ctx.fillStyle = board[r][c] === PLAYER_RED ? '#ff4444' : '#ffff00';
          ctx.shadowColor = '#0008';
          ctx.shadowBlur = 5;
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }
  }

  // --- Game Logic ---
  function checkWin(board, player) {
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c] !== player) continue;
        if (c + 3 < cols &&
          board[r][c + 1] === player &&
          board[r][c + 2] === player &&
          board[r][c + 3] === player) return true;
        if (r + 3 < rows &&
          board[r + 1][c] === player &&
          board[r + 2][c] === player &&
          board[r + 3][c] === player) return true;
        if (r + 3 < rows && c + 3 < cols &&
          board[r + 1][c + 1] === player &&
          board[r + 2][c + 2] === player &&
          board[r + 3][c + 3] === player) return true;
        if (r - 3 >= 0 && c + 3 < cols &&
          board[r - 1][c + 1] === player &&
          board[r - 2][c + 2] === player &&
          board[r - 3][c + 3] === player) return true;
      }
    }
    return false;
  }

  function isBoardFull(board) {
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c] === PLAYER_NONE) return false;
      }
    }
    return true;
  }

  function dropPiece(board, col, player) {
    for (let r = rows - 1; r >= 0; r--) {
      if (board[r][col] === PLAYER_NONE) {
        board[r][col] = player;
        return true;
      }
    }
    return false;
  }

  function getAvailableMoves(board) {
    const moves = [];
    for (let c = 0; c < cols; c++) {
      if (board[0][c] === PLAYER_NONE) moves.push(c);
    }
    return moves;
  }

  // --- AI Logic ---
  function aiMove() {
    const moves = getAvailableMoves(board);
    if (moves.length === 0) return -1;
    // Simple random AI
    return moves[Math.floor(Math.random() * moves.length)];
  }

  // --- Match Management ---

  function generateMatchId() {
    return 'match_' + Math.random().toString(36).substr(2, 9);
  }

  function cleanupMatches() {
    const now = Date.now();
    for (const id in matches) {
      const m = matches[id];
      if (!m) continue;
      if (m.state === 'ended' && (now - m.endedAt) > 5 * 60 * 1000) {
        delete matches[id];
        continue;
      }
      if ((now - m.created) > 30 * 60 * 1000) {
        delete matches[id];
      }
    }
  }

  function refreshMatches() {
    cleanupMatches();
    matchesContainer.innerHTML = '';

    const allMatches = Object.values(matches).filter(m => m.mode === 'pvp');

    if (allMatches.length === 0) {
      matchesContainer.innerHTML = '<div class="no-matches">No matches available.</div>';
      return;
    }

    allMatches.sort((a, b) => b.created - a.created);

    let anyShown = false;
    allMatches.forEach(m => {
      // Hide matches that include you
      if (m.players.includes(username)) return;

      const matchDiv = document.createElement('div');
      matchDiv.className = 'matchItem';

      const playersDiv = document.createElement('div');
      playersDiv.className = 'playerInfo';

      m.players.forEach(p => {
        const av = document.createElement('div');
        av.className = 'avatar-circle';
        av.textContent = p[0].toUpperCase();
        av.style.backgroundColor = stringToColor(p);
        const nameSpan = document.createElement('span');
        nameSpan.textContent = p;
        playersDiv.appendChild(av);
        playersDiv.appendChild(nameSpan);
      });

      const joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';

      if (gameId) {
        joinBtn.disabled = true;
        joinBtn.textContent = 'In Match';
      } else if (m.state !== 'waiting' || m.players.length >= 2) {
        joinBtn.disabled = true;
        joinBtn.textContent = m.state !== 'waiting' ? 'Unavailable' : 'Full';
      } else {
        joinBtn.onclick = () => {
          joinMatch(m.id);
        };
      }

      matchDiv.appendChild(playersDiv);
      matchDiv.appendChild(joinBtn);
      matchesContainer.appendChild(matchDiv);
      anyShown = true;
    });

    if (!anyShown) {
      matchesContainer.innerHTML = '<div class="no-matches">No matches available.</div>';
    }
  }

  function createMatch() {
    if (gameId) return; // Prevent creating if in match

    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;
    aiDifficulty = Array.from(aiButtons).find(b => b.classList.contains('active')).dataset.level;

    if (gameMode === 'ai') {
      // AI matches are client-only, do not add to global matches store
      gameId = 'local_ai_match';
      currentGame = {
        id: gameId,
        players: [username, 'AI'],
        state: 'playing',
        rows: rows,
        cols: cols,
        mode: 'ai',
        difficulty: aiDifficulty,
        created: Date.now(),
        endedAt: null,
      };
      initBoard();
      currentPlayer = PLAYER_RED;
      myPlayer = PLAYER_RED;
      gameState = 'playing';
      statusText.textContent = 'Your turn';
      updateUiState();
      drawBoard();
      return;
    }

    // PvP match
    const id = generateMatchId();
    const match = {
      id: id,
      players: [username],
      state: 'waiting',
      rows: rows,
      cols: cols,
      mode: 'pvp',
      difficulty: aiDifficulty,
      created: Date.now(),
      endedAt: null,
      board: null,
      turn: null,
    };
    matches[id] = match;
    gameId = id;
    currentGame = match;

    initBoard();
    currentPlayer = PLAYER_RED;
    myPlayer = PLAYER_RED;
    gameState = 'waiting';

    statusText.textContent = 'Waiting for opponent to join...';
    updateUiState();
    drawBoard();
    refreshMatches();
  }

  function joinMatch(id) {
    if (gameId) return; // Can't join if already in a match
    const match = matches[id];
    if (!match) return alert('Match not found!');
    if (match.players.length >= 2 || match.state !== 'waiting') return alert('Match full or unavailable!');

    match.players.push(username);
    match.state = 'playing';
    match.turn = PLAYER_RED;
    gameId = id;
    currentGame = match;
    myPlayer = PLAYER_YELLOW;
    rows = match.rows;
    cols = match.cols;
    gameMode = match.mode;
    aiDifficulty = match.difficulty;

    initBoard();
    currentPlayer = PLAYER_RED;
    gameState = 'playing';

    statusText.textContent = 'Match started. Your turn: ' + (myPlayer === currentPlayer ? 'Yes' : 'No');
    updateUiState();
    drawBoard();
    refreshMatches();
  }

  function leaveMatch() {
    if (!gameId) return;
    if (gameId === 'local_ai_match') {
      // Local AI match, just reset
      gameId = null;
      currentGame = null;
      myPlayer = PLAYER_NONE;
      gameState = 'idle';
      statusText.textContent = 'You left the match.';
      updateUiState();
      drawBoard();
      return;
    }

    const match = matches[gameId];
    if (!match) return;

    // Remove player from match
    match.players = match.players.filter(p => p !== username);

    if (match.players.length === 0) {
      // No players left, delete match
      delete matches[gameId];
    } else {
      // If creator leaves, delete match (you can customize this if needed)
      if (match.players[0] !== username) {
        // If you're NOT creator, just leave, keep match
      } else {
        // Creator left, delete match and notify players
        delete matches[gameId];
      }
    }

    gameId = null;
    currentGame = null;
    myPlayer = PLAYER_NONE;
    gameState = 'idle';
    statusText.textContent = 'You left the match.';
    updateUiState();
    drawBoard();
    refreshMatches();
  }

  // UI update
  function updateUiState() {
    const inMatch = !!gameId;
    createBtn.disabled = inMatch;
    leaveBtn.disabled = !inMatch;
    rowSel.disabled = inMatch;
    colSel.disabled = inMatch;
    modeSel.disabled = inMatch;
    aiDifficultyDiv.style.display = (!inMatch && modeSel.value === 'ai') ? 'flex' : 'none';
  }

  aiButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      aiButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.dataset.level;
    });
  });

  function updateAiDifficultyVisibility() {
    if (modeSel.value === 'ai') {
      aiDifficultyDiv.style.display = 'flex';
    } else {
      aiDifficultyDiv.style.display = 'none';
    }
  }

  modeSel.addEventListener('change', () => {
    updateAiDifficultyVisibility();
  });

  // --- Game Canvas Click ---
  canvas.addEventListener('click', e => {
    if (gameState !== 'playing' || !gameId) return;
    if (myPlayer !== currentPlayer) {
      statusText.textContent = 'Not your turn!';
      return;
    }

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const colWidth = canvas.width / cols;
    const colClicked = Math.floor(x / colWidth);

    if (!dropPiece(board, colClicked, currentPlayer)) {
      statusText.textContent = 'Column full! Choose another.';
      return;
    }

    drawBoard();

    if (checkWin(board, currentPlayer)) {
      statusText.textContent = `Player ${currentPlayer === PLAYER_RED ? 'Red' : 'Yellow'} wins!`;
      gameState = 'ended';
      if (currentGame) {
        currentGame.state = 'ended';
        currentGame.endedAt = Date.now();
      }
      updateUiState();
      return;
    }

    if (isBoardFull(board)) {
      statusText.textContent = 'Draw! Board full.';
      gameState = 'ended';
      if (currentGame) {
        currentGame.state = 'ended';
        currentGame.endedAt = Date.now();
      }
      updateUiState();
      return;
    }

    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
    if (currentGame) currentGame.turn = currentPlayer;

    if (gameMode === 'ai' && currentPlayer === PLAYER_YELLOW) {
      statusText.textContent = 'AI is thinking...';
      setTimeout(() => {
        const aiCol = aiMove();
        if (aiCol >= 0) {
          dropPiece(board, aiCol, PLAYER_YELLOW);
          drawBoard();

          if (checkWin(board, PLAYER_YELLOW)) {
            statusText.textContent = 'AI (Yellow) wins!';
            gameState = 'ended';
            if (currentGame) {
              currentGame.state = 'ended';
              currentGame.endedAt = Date.now();
            }
            updateUiState();
            return;
          }

          if (isBoardFull(board)) {
            statusText.textContent = 'Draw! Board full.';
            gameState = 'ended';
            if (currentGame) {
              currentGame.state = 'ended';
              currentGame.endedAt = Date.now();
            }
            updateUiState();
            return;
          }
        }
        currentPlayer = PLAYER_RED;
        if (currentGame) currentGame.turn = currentPlayer;
        statusText.textContent = 'Your turn';
      }, 900);
    } else {
      statusText.textContent = currentPlayer === myPlayer ? 'Your turn' : 'Waiting for opponent move...';
    }
  });

  // --- Button Listeners ---
  createBtn.addEventListener('click', () => {
    createMatch();
  });

  leaveBtn.addEventListener('click', () => {
    leaveMatch();
  });

  refreshMatchesBtn.addEventListener('click', () => {
    refreshMatches();
  });

  // Initialize dropdowns and UI
  fillDropdown(rowSel, 4, 10, 6);
  fillDropdown(colSel, 4, 10, 7);
  updateAiDifficultyVisibility();
  updateUiState();

  // Initialize empty board
  initBoard();
  drawBoard();

  // Disable form submit on enter inside username input
  usernameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !usernameSubmit.disabled) {
      usernameSubmit.click();
      e.preventDefault();
    }
  });
});
</script>

</body>
</html>
