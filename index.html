<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Connect Four</title>
  <script src="https://discord.com/assets/embedded-app-sdk.js"></script>
  <style>
    :root {
      --bg-color: #1e1e2f;
      --board-color: #29293d;
      --highlight: #ffaa00;
      --red: #f44336;
      --yellow: #fdd835;
    }
    body {
      background: var(--bg-color);
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    h1 {
      margin-bottom: 10px;
      font-size: 32px;
      color: var(--highlight);
    }
    .menu {
      margin-bottom: 15px;
    }
    select, button {
      margin: 5px;
      padding: 10px 18px;
      font-size: 16px;
      background: var(--board-color);
      color: white;
      border: 2px solid var(--highlight);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 3px 0 var(--highlight);
      user-select: none;
    }
    button:hover, select:hover {
      transform: scale(1.05);
    }
    button:active {
      transform: scale(0.97);
      box-shadow: 0 1px 0 var(--highlight);
    }
    #aiDifficultyButtons {
      margin-top: 10px;
      margin-bottom: 10px;
    }
    #aiDifficultyButtons button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      margin: 0 5px;
      border: 1.5px solid var(--highlight);
      background: var(--board-color);
      color: white;
      box-shadow: 0 2px 0 var(--highlight);
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
    }
    #aiDifficultyButtons button:hover {
      transform: scale(1.1);
      background: var(--highlight);
      color: #111;
    }
    #aiDifficultyButtons button.active {
      background: var(--highlight);
      color: #111;
      box-shadow: none;
      transform: scale(1.1);
    }
    canvas {
      background: var(--board-color);
      margin: 20px auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 10px #0008;
    }
    #status {
      font-size: 20px;
      margin-top: 10px;
      font-weight: bold;
      user-select: none;
      min-height: 28px;
    }
    #matchList {
      margin-top: 15px;
      text-align: left;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
      font-size: 16px;
      color: white;
      user-select: none;
    }
    #matchList h3 {
      margin-bottom: 8px;
      color: var(--highlight);
    }
    .matchItem {
      margin-bottom: 8px;
      padding: 6px 10px;
      background: var(--board-color);
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 3px 0 var(--highlight);
    }
    .matchItem button {
      padding: 4px 10px;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      background: var(--highlight);
      color: #111;
      border: none;
      box-shadow: none;
      transition: transform 0.15s ease;
      user-select: none;
    }
    .matchItem button:hover {
      transform: scale(1.1);
    }
  </style>
</head>
<body>
  <h1>Connect Four</h1>

  <div class="menu">
    Rows:
    <select id="rows"></select>
    Columns:
    <select id="cols"></select>
    Mode:
    <select id="mode">
      <option value="pvp">Player vs Player</option>
      <option value="ai">Player vs AI</option>
    </select>
    <button id="create">Create Game</button>
    <button id="leave" disabled>Leave Game</button>
  </div>

  <div id="aiDifficultyButtons" style="display:none;">
    Difficulty:
    <button data-level="easy">Easy</button>
    <button data-level="normal" class="active">Normal</button>
    <button data-level="hard">Hard</button>
    <button data-level="insane">Insane</button>
    <button data-level="impossible">Impossible</button>
  </div>

  <canvas id="gameCanvas"></canvas>
  <div id="status">Select options and press Create.</div>

  <div id="matchList">
    <h3>Available Matches</h3>
    <div id="matchesContainer">No matches available.</div>
  </div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');
  const matchesContainer = document.getElementById('matchesContainer');

  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle';
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let currentGame = null;
  let aiDifficulty = 'normal';

  let matches = {};

  function setupUI() {
    const rowSel = document.getElementById('rows');
    const colSel = document.getElementById('cols');
    for (let i = 4; i <= 10; i++) {
      rowSel.add(new Option(i, i));
      colSel.add(new Option(i, i));
    }
    rowSel.value = rows;
    colSel.value = cols;
    rowSel.onchange = () => { rows = +rowSel.value; };
    colSel.onchange = () => { cols = +colSel.value; };
    const modeSel = document.getElementById('mode');
    modeSel.onchange = () => {
      gameMode = modeSel.value;
      toggleAIDifficulty(gameMode === 'ai');
    };
    document.getElementById('create').onclick = onCreate;
    document.getElementById('leave').onclick = onLeave;
    canvas.addEventListener('click', onClick);

    const aiButtons = document.querySelectorAll('#aiDifficultyButtons button');
    aiButtons.forEach(btn => {
      btn.onclick = () => {
        aiButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        aiDifficulty = btn.getAttribute('data-level');
        updateStatus(`AI difficulty set to ${aiDifficulty}`);
      };
    });

    updateUIButtons();
    renderMatchList();
  }

  function toggleAIDifficulty(show) {
    const div = document.getElementById('aiDifficultyButtons');
    div.style.display = show ? 'block' : 'none';
  }

  function onCreate() {
    rows = +document.getElementById('rows').value;
    cols = +document.getElementById('cols').value;
    initBoard();
    gameId = Math.random().toString(36).substr(2, 8);
    currentGame = { id: gameId, rows, cols, mode: gameMode, difficulty: aiDifficulty, state: 'waiting' };
    myPlayer = PLAYER_RED;
    currentPlayer = PLAYER_RED;

    if (gameMode === 'ai') {
      currentGame.state = 'playing';
      gameState = 'playing';
      updateStatus("Your turn!");
      toggleMatchList(false);
      updateUIButtons();
    } else {
      gameState = 'waiting';
      updateStatus("Waiting for opponent...");
      toggleMatchList(true);
      addMatch(currentGame);
    }

    broadcast({ type: 'create', game: currentGame });
  }

  function onJoinGame(id) {
    if (!matches[id]) {
      updateStatus("Match not found.");
      return;
    }
    currentGame = matches[id];
    rows = currentGame.rows;
    cols = currentGame.cols;
    gameId = currentGame.id;
    myPlayer = PLAYER_YELLOW;
    currentPlayer = PLAYER_RED;
    initBoard();
    gameState = 'playing';
    updateStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
    broadcast({ type: 'join', gameId });
    toggleMatchList(false);
    updateUIButtons();

    if (gameMode === 'ai' && currentPlayer !== myPlayer) {
      setTimeout(aiMove, 500);
    }
  }

  function onLeave() {
    broadcast({ type: 'leave', gameId });
    resetGame();
    toggleMatchList(true);
  }

  function resetGame() {
    gameState = 'idle';
    currentGame = null;
    board = [];
    myPlayer = PLAYER_NONE;
    gameId = null;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateStatus("Game ended.");
    updateUIButtons();
  }

  function initBoard() {
    board = Array.from({ length: rows }, () => Array(cols).fill(PLAYER_NONE));
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    drawBoard();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        ctx.fillStyle = board[y][x] === PLAYER_RED ? "#f44336" :
                        board[y][x] === PLAYER_YELLOW ? "#fdd835" : "white";
        ctx.beginPath();
        ctx.arc(35 + x * 70, 35 + y * 70, 30, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }

  function onClick(e) {
    if (gameState !== 'playing' || myPlayer !== currentPlayer) return;
    const col = Math.floor(e.offsetX / 70);
    if (col < 0 || col >= cols) return;

    for (let y = rows - 1; y >= 0; y--) {
      if (board[y][col] === PLAYER_NONE) {
        board[y][col] = myPlayer;
        drawBoard();
        broadcast({ type: 'move', col, row: y, player: myPlayer, gameId });

        if (checkWin()) {
          gameState = 'ended';
          updateStatus("You win!", 'win');
          broadcast({ type: 'end', winner: myPlayer, gameId });
        } else if (isBoardFull()) {
          gameState = 'ended';
          updateStatus("Draw!", 'draw');
          broadcast({ type: 'end', winner: PLAYER_NONE, gameId });
        } else {
          currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
          updateStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");

          if (gameMode === 'ai' && currentPlayer !== myPlayer) {
            setTimeout(aiMove, 500);
          }
        }
        break;
      }
    }
  }

  function isBoardFull() {
    return board.every(row => row.every(cell => cell !== PLAYER_NONE));
  }

  // Simple AI logic: random valid move for easy, placeholder for other difficulties
  function aiMove() {
    if (gameState !== 'playing' || currentPlayer !== (myPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED)) return;

    let col;
    if (aiDifficulty === 'easy') {
      const validCols = [];
      for (let c = 0; c < cols; c++) {
        if (board[0][c] === PLAYER_NONE) validCols.push(c);
      }
      col = validCols[Math.floor(Math.random() * validCols.length)];
    } else {
      col = findBestMove();
    }

    for (let y = rows - 1; y >= 0; y--) {
      if (board[y][col] === PLAYER_NONE) {
        board[y][col] = currentPlayer;
        drawBoard();
        broadcast({ type: 'move', col, row: y, player: currentPlayer, gameId });

        if (checkWin()) {
          gameState = 'ended';
          updateStatus("You lose.", 'lose');
          broadcast({ type: 'end', winner: currentPlayer, gameId });
        } else if (isBoardFull()) {
          gameState = 'ended';
          updateStatus("Draw!", 'draw');
          broadcast({ type: 'end', winner: PLAYER_NONE, gameId });
        } else {
          currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
          updateStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
        }
        break;
      }
    }
  }

  function findBestMove() {
    // Placeholder AI logic for higher difficulties: random valid move
    const validCols = [];
    for (let c = 0; c < cols; c++) {
      if (board[0][c] === PLAYER_NONE) validCols.push(c);
    }
    return validCols[Math.floor(Math.random() * validCols.length)];
  }

  function checkWin() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const player = board[y][x];
        if (player === PLAYER_NONE) continue;

        if (x + 3 < cols &&
          player === board[y][x + 1] &&
          player === board[y][x + 2] &&
          player === board[y][x + 3]) return true;

        if (y + 3 < rows &&
          player === board[y + 1][x] &&
          player === board[y + 2][x] &&
          player === board[y + 3][x]) return true;

        if (x + 3 < cols && y + 3 < rows &&
          player === board[y + 1][x + 1] &&
          player === board[y + 2][x + 2] &&
          player === board[y + 3][x + 3]) return true;

        if (x + 3 < cols && y - 3 >= 0 &&
          player === board[y - 1][x + 1] &&
          player === board[y - 2][x + 2] &&
          player === board[y - 3][x + 3]) return true;
      }
    }
    return false;
  }

  function updateStatus(text, result) {
    statusText.textContent = text;
    if (result === 'win') {
      statusText.style.color = "#4CAF50"; // green
    } else if (result === 'lose') {
      statusText.style.color = "#F44336"; // red
    } else if (result === 'draw') {
      statusText.style.color = "#FF9800"; // orange
    } else {
      statusText.style.color = "#FFFFFF"; // white default
    }
  }

  function updateUIButtons() {
    document.getElementById('leave').disabled = !(gameState === 'playing' || gameState === 'ended');
    document.getElementById('create').disabled = (gameState === 'playing' || gameState === 'waiting');
  }

  function addMatch(match) {
    matches[match.id] = match;
    renderMatchList();
  }

  function deleteMatch(id) {
    delete matches[id];
    renderMatchList();
  }

  function renderMatchList() {
    const availableMatches = Object.values(matches).filter(m => m.state === 'waiting');
    if (availableMatches.length === 0) {
      matchesContainer.textContent = "No matches available.";
      return;
    }
    matchesContainer.innerHTML = "";
    availableMatches.forEach(m => {
      const div = document.createElement('div');
      div.className = "matchItem";
      div.innerHTML = `
        <span>Match ${m.id} (${m.rows}x${m.cols}) Mode: ${m.mode}</span>
        <button>Join</button>
      `;
      const btn = div.querySelector('button');
      btn.onclick = () => onJoinGame(m.id);
      matchesContainer.appendChild(div);
    });
  }

  function toggleMatchList(show) {
    document.getElementById('matchList').style.display = show ? 'block' : 'none';
  }

  // Broadcast wrapper for Discord Embedded Activity SDK
  function broadcast(data) {
    if (typeof DiscordSDK !== "undefined" && DiscordSDK.activity) {
      DiscordSDK.activity.broadcast(data);
    } else {
      console.log("Broadcast:", data);
    }
  }

  // Handle incoming events from Discord
  function handleEvent(data) {
    switch(data.type) {
      case 'create':
        addMatch(data.game);
        break;
      case 'join':
        if (data.gameId === gameId && data.player !== myPlayer) {
          gameState = 'playing';
          updateStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
          toggleMatchList(false);
          updateUIButtons();
        }
        deleteMatch(data.gameId);
        break;
      case 'move':
        if (data.gameId === gameId && data.player !== myPlayer) {
          board[data.row][data.col] = data.player;
          drawBoard();

          if (checkWin()) {
            gameState = 'ended';
            updateStatus("You lose.", 'lose');
            updateUIButtons();
          } else if (isBoardFull()) {
            gameState = 'ended';
            updateStatus("Draw!", 'draw');
            updateUIButtons();
          } else {
            currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;
            updateStatus(currentPlayer === myPlayer ? "Your turn!" : "Opponent's turn...");
          }
        }
        break;
      case 'end':
        if (data.gameId === gameId) {
          gameState = 'ended';
          updateStatus(data.winner === myPlayer ? "You win!" : "You lose.", data.winner === myPlayer ? 'win' : 'lose');
          updateUIButtons();
          toggleMatchList(true);
        }
        break;
      case 'leave':
        deleteMatch(data.gameId);
        if (gameId === data.gameId) {
          resetGame();
          toggleMatchList(true);
        }
        break;
    }
  }

  function setup() {
    setupUI();
    if (typeof DiscordSDK !== "undefined") {
      DiscordSDK.ready().then(() => {
        DiscordSDK.activity.on('broadcast', handleEvent);
      });
    } else {
      updateStatus("DiscordSDK not available (test mode).");
    }
  }

  setup();
</script>
</body>
</html>
