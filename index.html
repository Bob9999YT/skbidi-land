<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Connect Four</title>
<style>
  * {
    box-sizing: border-box;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    background-color: #1e1e2f;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #fff;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100vh;
  }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
  }

  h1 {
    font-size: 2rem;
    color: #ffaa00;
    margin: 0;
    text-align: center;
  }

  .user-profile {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #29293d;
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #ffaa00;
    user-select: none;
  }

  .user-profile .avatar-circle {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #ffaa00;
    color: #111;
    font-weight: 700;
    font-size: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-transform: uppercase;
  }

  .user-profile span {
    font-weight: 600;
    color: #ffaa00;
  }

  .menu {
    display: flex;
    flex-wrap: wrap;
    gap: 14px 24px;
    justify-content: center;
    align-items: center;
    margin-bottom: 20px;
    width: 100%;
    max-width: 600px;
  }
  .menu label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 600;
    white-space: nowrap;
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 8px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #29293d;
    color: white;
    cursor: pointer;
    box-shadow: 0 3px 0 #ffaa00;
    transition: all 0.2s ease;
    min-width: 90px;
  }
  select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }
  select:hover, button:hover:not(:disabled) {
    transform: scale(1.05);
  }
  button:active:not(:disabled) {
    transform: scale(0.97);
    box-shadow: 0 1px 0 #ffaa00;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  button:disabled:hover {
    transform: none;
  }
  #aiDifficultyButtons {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 15px;
    width: 100%;
    max-width: 600px;
  }
  #aiDifficultyButtons button {
    min-width: 70px;
    padding: 6px 12px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1.5px solid #ffaa00;
    background: #29293d;
    box-shadow: 0 2px 0 #ffaa00;
    color: white;
    cursor: pointer;
  }
  #aiDifficultyButtons button.active {
    background: #ffaa00;
    color: #111;
    box-shadow: none;
    transform: scale(1.1);
  }
  #aiDifficultyButtons button:hover:not(.active) {
    background: #ffaa00;
    color: #111;
    transform: scale(1.1);
  }
  canvas {
    background: #29293d;
    border-radius: 12px;
    box-shadow: 0 0 10px #0008;
    margin: 20px 0;
    cursor: pointer;
    max-width: 100%;
    height: auto;
  }
  #status {
    font-size: 1.1rem;
    font-weight: 700;
    margin-top: 5px;
    min-height: 24px;
    text-align: center;
    max-width: 600px;
  }
  #matchList {
    margin-top: 15px;
    max-width: 600px;
    width: 100%;
    text-align: left;
    color: white;
  }
  #matchList h3 {
    color: #ffaa00;
    margin-bottom: 10px;
    text-align: center;
  }
  #matchesContainer {
    max-height: 240px;
    overflow-y: auto;
    border-radius: 6px;
    border: 1.5px solid #ffaa00;
    padding: 8px;
    background: #1f1f2b;
  }
  .matchItem {
    background: #29293d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 3px 0 #ffaa00;
  }
  .matchItem .playerInfo {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .matchItem .playerInfo .avatar-circle {
    width: 28px;
    height: 28px;
    font-size: 16px;
  }
  .matchItem button {
    background: #ffaa00;
    border: none;
    border-radius: 4px;
    color: #111;
    padding: 6px 12px;
    cursor: pointer;
    transition: transform 0.15s ease;
    font-size: 0.9rem;
    box-shadow: none;
  }
  .matchItem button:hover:not(:disabled) {
    transform: scale(1.1);
  }
  .matchItem button:disabled {
    background: #444;
    cursor: not-allowed;
    transform: none;
  }
  #matchesContainer::-webkit-scrollbar {
    width: 8px;
  }
  #matchesContainer::-webkit-scrollbar-thumb {
    background-color: #ffaa00;
    border-radius: 4px;
  }
  .no-matches {
    text-align: center;
    color: #888;
    padding: 20px;
  }
  #usernamePromptContainer {
    background: #29293d;
    border: 2px solid #ffaa00;
    border-radius: 12px;
    padding: 20px;
    max-width: 360px;
    width: 90%;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #usernamePromptContainer input {
    font-size: 1.2rem;
    padding: 10px 14px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #1f1f2b;
    color: white;
    width: 100%;
    margin-bottom: 15px;
  }
  #usernamePromptContainer button {
    font-size: 1.1rem;
    padding: 8px 20px;
    border-radius: 6px;
    border: 2px solid #ffaa00;
    background: #ffaa00;
    color: #111;
    cursor: pointer;
    box-shadow: 0 3px 0 #b27f00;
    transition: all 0.2s ease;
  }
  #usernamePromptContainer button:hover {
    background: #ffbb33;
    box-shadow: none;
  }
  #usernamePromptContainer button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<div id="usernamePromptContainer">
  <h2 style="color:#ffaa00; margin-bottom:10px;">Enter Your Username</h2>
  <input id="usernameInput" type="text" maxlength="16" placeholder="Your username" />
  <button id="usernameSubmit" disabled>Start Playing</button>
</div>

<div class="header" style="display:none;">
  <h1>Connect Four</h1>
  <div class="user-profile">
    <div class="avatar-circle" id="userAvatar">G</div>
    <span id="username">Guest</span>
  </div>
</div>

<div class="menu" style="display:none;">
  <label for="rows">Rows:</label>
  <select id="rows" name="rows"></select>

  <label for="cols">Columns:</label>
  <select id="cols" name="cols"></select>

  <label for="mode">Mode:</label>
  <select id="mode" name="mode">
    <option value="pvp">Player vs Player</option>
    <option value="ai">Player vs AI</option>
  </select>

  <button id="create">Create Game</button>
  <button id="leave" disabled>Leave Game</button>
</div>

<div id="aiDifficultyButtons" style="display:none;">
  <button data-level="easy">Easy</button>
  <button data-level="normal" class="active">Normal</button>
  <button data-level="hard">Hard</button>
  <button data-level="insane">Insane</button>
  <button data-level="impossible">Impossible</button>
</div>

<canvas id="gameCanvas" width="490" height="420" style="display:none;"></canvas>
<div id="status" style="max-width:600px; text-align:center; margin-top:10px; display:none;">Click "Create Game" to start playing!</div>

<div id="matchList" style="display:none;">
  <h3>Available Matches</h3>
  <div id="matchesContainer">No matches available.</div>
</div>

<script>
(() => {
  const PLAYER_NONE = 0, PLAYER_RED = 1, PLAYER_YELLOW = 2;

  let isInMatch = false;

  let currentUser = { username: null };
  let currentUserId = null;

  let rows = 6, cols = 7;
  let board = [];
  let currentPlayer = PLAYER_RED;
  let gameState = 'idle'; // idle, waiting, playing, ended
  let myPlayer = PLAYER_NONE;
  let gameId = null;
  let gameMode = 'pvp';
  let aiDifficulty = 'normal';

  const matches = {}; // id -> match object, global matches only for pvp

  // DOM Elements
  const usernamePromptContainer = document.getElementById('usernamePromptContainer');
  const usernameInput = document.getElementById('usernameInput');
  const usernameSubmit = document.getElementById('usernameSubmit');
  const header = document.querySelector('.header');
  const userAvatarDiv = document.getElementById('userAvatar');
  const usernameSpan = document.getElementById('username');

  const menu = document.querySelector('.menu');
  const rowSel = document.getElementById('rows');
  const colSel = document.getElementById('cols');
  const modeSel = document.getElementById('mode');
  const createBtn = document.getElementById('create');
  const leaveBtn = document.getElementById('leave');

  const aiDifficultyDiv = document.getElementById('aiDifficultyButtons');
  const aiButtons = aiDifficultyDiv.querySelectorAll('button');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusText = document.getElementById('status');

  const matchesContainer = document.getElementById('matchesContainer');
  const matchListDiv = document.getElementById('matchList');

  // Utils
  function makeId() {
    return 'match_' + Math.random().toString(36).substr(2, 9);
  }

  function getAvatarColor(name) {
    // Simple hash to color
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const colors = [
      '#f44336', '#e91e63', '#9c27b0', '#673ab7',
      '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4',
      '#009688', '#4caf50', '#8bc34a', '#cddc39',
      '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'
    ];
    return colors[Math.abs(hash) % colors.length];
  }

  function updateUserProfile() {
    usernameSpan.textContent = currentUser.username;
    const firstLetter = currentUser.username.charAt(0).toUpperCase();
    userAvatarDiv.textContent = firstLetter;
    userAvatarDiv.style.backgroundColor = getAvatarColor(currentUser.username);
  }

  // Board functions
  function initBoard() {
    board = Array.from({length: rows}, () => Array(cols).fill(PLAYER_NONE));
    updateCanvasSize();
  }

  function updateCanvasSize() {
    canvas.width = cols * 70;
    canvas.height = rows * 70;
    if(board.length) drawBoard();
  }

  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Background grid
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for(let r = 0; r < rows; r++) {
      for(let c = 0; c < cols; c++) {
        let x = c * 70;
        let y = r * 70;
        ctx.fillStyle = '#1e1e2f';
        ctx.beginPath();
        ctx.arc(x + 35, y + 35, 30, 0, 2 * Math.PI);
        ctx.fill();

        if(board[r][c] === PLAYER_RED) {
          ctx.fillStyle = '#ff3333';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        } else if(board[r][c] === PLAYER_YELLOW) {
          ctx.fillStyle = '#ffff66';
          ctx.beginPath();
          ctx.arc(x + 35, y + 35, 27, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
  }

  // Game logic
  function findLowestEmptyRow(col) {
    for(let r = rows - 1; r >= 0; r--) {
      if(board[r][col] === PLAYER_NONE) return r;
    }
    return -1;
  }

  function checkWin(player) {
    // Check horizontal
    for(let r = 0; r < rows; r++) {
      for(let c = 0; c <= cols - 4; c++) {
        if(board[r][c] === player && board[r][c+1] === player && board[r][c+2] === player && board[r][c+3] === player)
          return true;
      }
    }
    // Check vertical
    for(let c = 0; c < cols; c++) {
      for(let r = 0; r <= rows - 4; r++) {
        if(board[r][c] === player && board[r+1][c] === player && board[r+2][c] === player && board[r+3][c] === player)
          return true;
      }
    }
    // Check diagonal /
    for(let r = 3; r < rows; r++) {
      for(let c = 0; c <= cols - 4; c++) {
        if(board[r][c] === player && board[r-1][c+1] === player && board[r-2][c+2] === player && board[r-3][c+3] === player)
          return true;
      }
    }
    // Check diagonal \
    for(let r = 0; r <= rows - 4; r++) {
      for(let c = 0; c <= cols - 4; c++) {
        if(board[r][c] === player && board[r+1][c+1] === player && board[r+2][c+2] === player && board[r+3][c+3] === player)
          return true;
      }
    }
    return false;
  }

  function checkDraw() {
    for(let c = 0; c < cols; c++) {
      if(board[0][c] === PLAYER_NONE) return false;
    }
    return true;
  }

  // Networking simulation for global matches
  // Since we don't have a real server, we'll simulate server with localStorage + events

  const STORAGE_KEY = 'connect_four_global_matches';

  function loadGlobalMatches() {
    let data = localStorage.getItem(STORAGE_KEY);
    if(!data) return {};
    try {
      return JSON.parse(data);
    } catch {
      return {};
    }
  }

  function saveGlobalMatches() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
  }

  function refreshMatchesList() {
    // Remove all, then add filtered matches
    matchesContainer.innerHTML = '';
    let hasAny = false;

    for(let id in matches) {
      const m = matches[id];
      if(m.mode !== 'pvp') continue; // no AI matches shown here
      if(m.status !== 'waiting') continue;
      if(m.creatorId === currentUserId) continue; // hide own matches

      hasAny = true;

      const div = document.createElement('div');
      div.className = 'matchItem';

      const playersDiv = document.createElement('div');
      playersDiv.className = 'playerInfo';

      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar-circle';
      avatarDiv.textContent = m.creatorName.charAt(0).toUpperCase();
      avatarDiv.style.backgroundColor = getAvatarColor(m.creatorName);

      const nameSpan = document.createElement('span');
      nameSpan.textContent = m.creatorName;

      playersDiv.appendChild(avatarDiv);
      playersDiv.appendChild(nameSpan);

      div.appendChild(playersDiv);

      const joinBtn = document.createElement('button');
      joinBtn.textContent = 'Join';
      joinBtn.disabled = isInMatch; // disable join if already in a match
      joinBtn.onclick = () => joinMatch(id);
      div.appendChild(joinBtn);

      matchesContainer.appendChild(div);
    }

    if(!hasAny) {
      matchesContainer.innerHTML = '<div class="no-matches">No matches available.</div>';
    }
  }

  function saveMatchesToStorage() {
    saveGlobalMatches();
    window.dispatchEvent(new Event('storage')); // notify other tabs
  }

  function createMatch() {
    if(isInMatch) return;
    gameId = makeId();
    currentPlayer = PLAYER_RED;
    myPlayer = PLAYER_RED;
    gameState = 'waiting';
    gameMode = modeSel.value;

    initBoard();

    // If PvP create global match entry
    if(gameMode === 'pvp') {
      matches[gameId] = {
        id: gameId,
        creatorId: currentUserId,
        creatorName: currentUser.username,
        rows,
        cols,
        mode: 'pvp',
        status: 'waiting',
        board: JSON.parse(JSON.stringify(board)),
        currentTurn: currentPlayer,
      };
      saveMatchesToStorage();
      updateStatus('Waiting for opponent to join...');
    } else {
      // AI mode: no global match created
      gameState = 'playing';
      myPlayer = PLAYER_RED;
      currentPlayer = PLAYER_RED;
      updateStatus('Your turn');
    }

    drawBoard();
    isInMatch = true;
    leaveBtn.disabled = false;

    updateUIForMatch();
  }

  function joinMatch(id) {
    if(isInMatch) return;

    if(!matches[id]) return alert('Match no longer available');

    const m = matches[id];
    if(m.status !== 'waiting') return alert('Match is not available');

    if(m.creatorId === currentUserId) return; // Cannot join own match

    gameId = id;
    gameMode = 'pvp';
    rows = m.rows;
    cols = m.cols;
    board = JSON.parse(JSON.stringify(m.board));
    currentPlayer = m.currentTurn;

    myPlayer = PLAYER_YELLOW;
    gameState = 'playing';

    // Update global match to started
    matches[id].status = 'playing';
    saveMatchesToStorage();

    drawBoard();
    isInMatch = true;
    leaveBtn.disabled = false;

    updateStatus(currentPlayer === myPlayer ? "Your turn" : "Opponent's turn");

    updateUIForMatch();
  }

  function leaveMatch() {
    if(!isInMatch) return;

    if(gameMode === 'pvp' && gameId && matches[gameId]) {
      // Delete match if you are creator or opponent leaving
      // If creator leaves: delete the match for all
      // If joiner leaves: delete match or set status to waiting?
      if(currentUserId === matches[gameId].creatorId) {
        delete matches[gameId];
      } else {
        // For simplicity, delete match on leave by any player
        delete matches[gameId];
      }
      saveMatchesToStorage();
    }

    gameId = null;
    gameState = 'idle';
    myPlayer = PLAYER_NONE;
    isInMatch = false;
    board = [];

    leaveBtn.disabled = true;

    updateStatus('Left the match.');
    drawEmptyBoard();

    updateUIForMatch();
    refreshMatchesList();
  }

  function updateStatus(text) {
    statusText.textContent = text;
  }

  // Draw empty board when not in match
  function drawEmptyBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Handle clicks on canvas to place piece
  canvas.onclick = function(evt) {
    if(gameState !== 'playing') return;
    if(!isInMatch) return;

    if(gameMode === 'pvp') {
      if(currentPlayer !== myPlayer) return;
    } else if(gameMode === 'ai') {
      if(currentPlayer !== myPlayer) return;
    }

    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const colClicked = Math.floor(x / 70);

    if(colClicked < 0 || colClicked >= cols) return;

    makeMove(colClicked);
  };

  // Make a move in the column
  function makeMove(col) {
    if(gameState !== 'playing') return;

    const r = findLowestEmptyRow(col);
    if(r === -1) return;

    board[r][col] = currentPlayer;
    drawBoard();

    if(checkWin(currentPlayer)) {
      gameState = 'ended';
      if(gameMode === 'pvp') {
        updateStatus(currentPlayer === myPlayer ? "You win!" : "Opponent wins!");
      } else {
        updateStatus(currentPlayer === myPlayer ? "You win!" : "AI wins!");
      }
      leaveBtn.disabled = false;
      return;
    }

    if(checkDraw()) {
      gameState = 'ended';
      updateStatus("It's a draw!");
      leaveBtn.disabled = false;
      return;
    }

    // Switch turn
    currentPlayer = currentPlayer === PLAYER_RED ? PLAYER_YELLOW : PLAYER_RED;

    if(gameMode === 'pvp') {
      updateStatus(currentPlayer === myPlayer ? "Your turn" : "Opponent's turn");
    } else if(gameMode === 'ai') {
      if(currentPlayer === myPlayer) {
        updateStatus("Your turn");
      } else {
        updateStatus("AI's turn");
        setTimeout(aiMove, 700);
      }
    }
  }

  // Simple AI move (random)
  function aiMove() {
    if(gameState !== 'playing') return;
    if(currentPlayer === myPlayer) return; // Not AI turn

    // Find valid columns
    const validCols = [];
    for(let c=0;c<cols;c++) {
      if(findLowestEmptyRow(c) !== -1) validCols.push(c);
    }
    if(validCols.length === 0) return;

    const chosenCol = validCols[Math.floor(Math.random()*validCols.length)];

    makeMove(chosenCol);
  }

  // UI updating on match start/end
  function updateUIForMatch() {
    if(isInMatch) {
      createBtn.disabled = true;
      rowSel.disabled = true;
      colSel.disabled = true;
      modeSel.disabled = true;
      leaveBtn.disabled = false;

      canvas.style.display = 'block';
      statusText.style.display = 'block';
      matchListDiv.style.display = 'none';
      aiDifficultyDiv.style.display = gameMode === 'ai' ? 'flex' : 'none';

    } else {
      createBtn.disabled = false;
      rowSel.disabled = false;
      colSel.disabled = false;
      modeSel.disabled = false;
      leaveBtn.disabled = true;

      canvas.style.display = 'none';
      statusText.style.display = 'block';
      matchListDiv.style.display = 'block';
      aiDifficultyDiv.style.display = 'none';
    }

    if(gameMode === 'pvp') {
      refreshMatchesList();
      matchListDiv.style.display = 'block';
    } else {
      matchListDiv.style.display = 'none';
    }
  }

  // Populate rows and cols selects
  function populateRowsCols() {
    rowSel.innerHTML = '';
    colSel.innerHTML = '';
    for(let r=4; r<=10; r++) {
      const opt = document.createElement('option');
      opt.value = r;
      opt.textContent = r;
      if(r === rows) opt.selected = true;
      rowSel.appendChild(opt);
    }
    for(let c=4; c<=10; c++) {
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c;
      if(c === cols) opt.selected = true;
      colSel.appendChild(opt);
    }
  }

  // Handle difficulty buttons
  aiButtons.forEach(btn => {
    btn.onclick = () => {
      aiButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      aiDifficulty = btn.dataset.level;
    };
  });

  // Event handlers
  usernameInput.addEventListener('input', () => {
    usernameSubmit.disabled = usernameInput.value.trim().length < 2;
  });

  usernameSubmit.onclick = () => {
    currentUser.username = usernameInput.value.trim();
    if(currentUser.username.length < 2) return;
    currentUserId = 'user_' + Math.random().toString(36).slice(2, 10); // random id for demo

    usernamePromptContainer.style.display = 'none';
    header.style.display = 'flex';
    menu.style.display = 'flex';
    statusText.style.display = 'block';
    matchListDiv.style.display = 'block';

    updateUserProfile();

    populateRowsCols();
    updateStatus('Click "Create Game" to start playing!');

    refreshMatchesList();
  };

  createBtn.onclick = () => {
    rows = parseInt(rowSel.value);
    cols = parseInt(colSel.value);
    gameMode = modeSel.value;
    aiDifficultyDiv.style.display = gameMode === 'ai' ? 'flex' : 'none';

    createMatch();
  };

  leaveBtn.onclick = () => {
    leaveMatch();
  };

  // Listen for localStorage changes for global matches syncing
  window.addEventListener('storage', e => {
    if(e.key === STORAGE_KEY) {
      const data = loadGlobalMatches();
      Object.assign(matches, data);
      refreshMatchesList();

      // If current match was deleted, force leave
      if(isInMatch && gameMode === 'pvp' && gameId && !matches[gameId]) {
        alert("Your match was ended.");
        leaveMatch();
      }
    }
  });

  // Refresh matches every 5 seconds to keep updated
  setInterval(() => {
    if(gameMode === 'pvp' && !isInMatch) {
      const data = loadGlobalMatches();
      Object.assign(matches, data);
      refreshMatchesList();
    }
  }, 5000);

})();
</script>

</body>
</html>
